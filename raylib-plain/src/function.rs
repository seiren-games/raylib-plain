/* automatically generated by raylib-plain */
#![allow(clippy::not_unsafe_ptr_arg_deref, clippy::too_many_arguments)]
use crate::str_to_c_char;
use raylib_plain_sys as rl;
use std::ffi::CStr;
pub use std::ffi::CString;
pub use std::os::raw::c_char;
pub use std::os::raw::c_int;
pub use std::os::raw::c_long;
pub use std::os::raw::c_uchar;
pub use std::os::raw::c_uint;
pub use std::os::raw::c_void;

pub use rl::AudioCallback;
pub use rl::AudioStream;
pub use rl::AutomationEvent;
pub use rl::AutomationEventList;
pub use rl::BoneInfo;
pub use rl::BoundingBox;
pub use rl::Camera;
pub use rl::Camera2D;
pub use rl::Camera3D;
pub use rl::Color;
pub use rl::FilePathList;
pub use rl::Font;
pub use rl::GlyphInfo;
pub use rl::Image;
pub use rl::LoadFileDataCallback;
pub use rl::LoadFileTextCallback;
pub use rl::Material;
pub use rl::MaterialMap;
pub use rl::Matrix;
pub use rl::Mesh;
pub use rl::Model;
pub use rl::ModelAnimation;
pub use rl::Music;
pub use rl::NPatchInfo;
pub use rl::Quaternion;
pub use rl::Ray;
pub use rl::RayCollision;
pub use rl::Rectangle;
pub use rl::RenderTexture;
pub use rl::RenderTexture2D;
pub use rl::SaveFileDataCallback;
pub use rl::SaveFileTextCallback;
pub use rl::Shader;
pub use rl::Sound;
pub use rl::Texture;
pub use rl::Texture2D;
pub use rl::TextureCubemap;
pub use rl::TraceLogCallback;
pub use rl::Transform;
pub use rl::Vector2;
pub use rl::Vector3;
pub use rl::Vector4;
pub use rl::VrDeviceInfo;
pub use rl::VrStereoConfig;
pub use rl::Wave;

/** Initialize window and OpenGL context */
pub fn init_window(width: c_int, height: c_int, title: &str) {
    unsafe { rl::InitWindow(width, height, str_to_c_char(title)) };
}

/** Close window and unload OpenGL context */
pub fn close_window() {
    unsafe { rl::CloseWindow() };
}

/** Check if application should close (KEY_ESCAPE pressed or windows close icon clicked) */
pub fn window_should_close() -> bool {
    return unsafe { rl::WindowShouldClose() };
}

/** Check if window has been initialized successfully */
pub fn is_window_ready() -> bool {
    return unsafe { rl::IsWindowReady() };
}

/** Check if window is currently fullscreen */
pub fn is_window_fullscreen() -> bool {
    return unsafe { rl::IsWindowFullscreen() };
}

/** Check if window is currently hidden (only PLATFORM_DESKTOP) */
pub fn is_window_hidden() -> bool {
    return unsafe { rl::IsWindowHidden() };
}

/** Check if window is currently minimized (only PLATFORM_DESKTOP) */
pub fn is_window_minimized() -> bool {
    return unsafe { rl::IsWindowMinimized() };
}

/** Check if window is currently maximized (only PLATFORM_DESKTOP) */
pub fn is_window_maximized() -> bool {
    return unsafe { rl::IsWindowMaximized() };
}

/** Check if window is currently focused (only PLATFORM_DESKTOP) */
pub fn is_window_focused() -> bool {
    return unsafe { rl::IsWindowFocused() };
}

/** Check if window has been resized last frame */
pub fn is_window_resized() -> bool {
    return unsafe { rl::IsWindowResized() };
}

/** Check if one specific window flag is enabled */
pub fn is_window_state(flag: c_uint) -> bool {
    return unsafe { rl::IsWindowState(flag) };
}

/** Set window configuration state using flags (only PLATFORM_DESKTOP) */
pub fn set_window_state(flags: c_uint) {
    unsafe { rl::SetWindowState(flags) };
}

/** Clear window configuration state flags */
pub fn clear_window_state(flags: c_uint) {
    unsafe { rl::ClearWindowState(flags) };
}

/** Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP) */
pub fn toggle_fullscreen() {
    unsafe { rl::ToggleFullscreen() };
}

/** Toggle window state: borderless windowed (only PLATFORM_DESKTOP) */
pub fn toggle_borderless_windowed() {
    unsafe { rl::ToggleBorderlessWindowed() };
}

/** Set window state: maximized, if resizable (only PLATFORM_DESKTOP) */
pub fn maximize_window() {
    unsafe { rl::MaximizeWindow() };
}

/** Set window state: minimized, if resizable (only PLATFORM_DESKTOP) */
pub fn minimize_window() {
    unsafe { rl::MinimizeWindow() };
}

/** Set window state: not minimized/maximized (only PLATFORM_DESKTOP) */
pub fn restore_window() {
    unsafe { rl::RestoreWindow() };
}

/** Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP) */
pub fn set_window_icon(image: Image) {
    unsafe { rl::SetWindowIcon(image) };
}

/** Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP) */
pub fn set_window_icons(images: *mut Image, count: c_int) {
    unsafe { rl::SetWindowIcons(images, count) };
}

/** Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB) */
pub fn set_window_title(title: &str) {
    unsafe { rl::SetWindowTitle(str_to_c_char(title)) };
}

/** Set window position on screen (only PLATFORM_DESKTOP) */
pub fn set_window_position(x: c_int, y: c_int) {
    unsafe { rl::SetWindowPosition(x, y) };
}

/** Set monitor for the current window */
pub fn set_window_monitor(monitor: c_int) {
    unsafe { rl::SetWindowMonitor(monitor) };
}

/** Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE) */
pub fn set_window_min_size(width: c_int, height: c_int) {
    unsafe { rl::SetWindowMinSize(width, height) };
}

/** Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE) */
pub fn set_window_max_size(width: c_int, height: c_int) {
    unsafe { rl::SetWindowMaxSize(width, height) };
}

/** Set window dimensions */
pub fn set_window_size(width: c_int, height: c_int) {
    unsafe { rl::SetWindowSize(width, height) };
}

/** Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP) */
pub fn set_window_opacity(opacity: f32) {
    unsafe { rl::SetWindowOpacity(opacity) };
}

/** Set window focused (only PLATFORM_DESKTOP) */
pub fn set_window_focused() {
    unsafe { rl::SetWindowFocused() };
}

/** Get native window handle */
pub fn get_window_handle() -> *mut c_void {
    return unsafe { rl::GetWindowHandle() };
}

/** Get current screen width */
pub fn get_screen_width() -> c_int {
    return unsafe { rl::GetScreenWidth() };
}

/** Get current screen height */
pub fn get_screen_height() -> c_int {
    return unsafe { rl::GetScreenHeight() };
}

/** Get current render width (it considers HiDPI) */
pub fn get_render_width() -> c_int {
    return unsafe { rl::GetRenderWidth() };
}

/** Get current render height (it considers HiDPI) */
pub fn get_render_height() -> c_int {
    return unsafe { rl::GetRenderHeight() };
}

/** Get number of connected monitors */
pub fn get_monitor_count() -> c_int {
    return unsafe { rl::GetMonitorCount() };
}

/** Get current connected monitor */
pub fn get_current_monitor() -> c_int {
    return unsafe { rl::GetCurrentMonitor() };
}

/** Get specified monitor position */
pub fn get_monitor_position(monitor: c_int) -> Vector2 {
    return unsafe { rl::GetMonitorPosition(monitor) };
}

/** Get specified monitor width (current video mode used by monitor) */
pub fn get_monitor_width(monitor: c_int) -> c_int {
    return unsafe { rl::GetMonitorWidth(monitor) };
}

/** Get specified monitor height (current video mode used by monitor) */
pub fn get_monitor_height(monitor: c_int) -> c_int {
    return unsafe { rl::GetMonitorHeight(monitor) };
}

/** Get specified monitor physical width in millimetres */
pub fn get_monitor_physical_width(monitor: c_int) -> c_int {
    return unsafe { rl::GetMonitorPhysicalWidth(monitor) };
}

/** Get specified monitor physical height in millimetres */
pub fn get_monitor_physical_height(monitor: c_int) -> c_int {
    return unsafe { rl::GetMonitorPhysicalHeight(monitor) };
}

/** Get specified monitor refresh rate */
pub fn get_monitor_refresh_rate(monitor: c_int) -> c_int {
    return unsafe { rl::GetMonitorRefreshRate(monitor) };
}

/** Get window position XY on monitor */
pub fn get_window_position() -> Vector2 {
    return unsafe { rl::GetWindowPosition() };
}

/** Get window scale DPI factor */
pub fn get_window_scale_dpi() -> Vector2 {
    return unsafe { rl::GetWindowScaleDPI() };
}

/** Get the human-readable, UTF-8 encoded name of the specified monitor */
pub fn get_monitor_name(monitor: c_int) -> String {
    return unsafe { CStr::from_ptr(rl::GetMonitorName(monitor)) }
        .to_string_lossy()
        .into();
}

/** Set clipboard text content */
pub fn set_clipboard_text(text: &str) {
    unsafe { rl::SetClipboardText(str_to_c_char(text)) };
}

/** Get clipboard text content */
pub fn get_clipboard_text() -> String {
    return unsafe { CStr::from_ptr(rl::GetClipboardText()) }
        .to_string_lossy()
        .into();
}

/** Enable waiting for events on EndDrawing(), no automatic event polling */
pub fn enable_event_waiting() {
    unsafe { rl::EnableEventWaiting() };
}

/** Disable waiting for events on EndDrawing(), automatic events polling */
pub fn disable_event_waiting() {
    unsafe { rl::DisableEventWaiting() };
}

/** Shows cursor */
pub fn show_cursor() {
    unsafe { rl::ShowCursor() };
}

/** Hides cursor */
pub fn hide_cursor() {
    unsafe { rl::HideCursor() };
}

/** Check if cursor is not visible */
pub fn is_cursor_hidden() -> bool {
    return unsafe { rl::IsCursorHidden() };
}

/** Enables cursor (unlock cursor) */
pub fn enable_cursor() {
    unsafe { rl::EnableCursor() };
}

/** Disables cursor (lock cursor) */
pub fn disable_cursor() {
    unsafe { rl::DisableCursor() };
}

/** Check if cursor is on the screen */
pub fn is_cursor_on_screen() -> bool {
    return unsafe { rl::IsCursorOnScreen() };
}

/** Set background color (framebuffer clear color) */
pub fn clear_background(color: Color) {
    unsafe { rl::ClearBackground(color) };
}

/** Setup canvas (framebuffer) to start drawing */
pub fn begin_drawing() {
    unsafe { rl::BeginDrawing() };
}

/** End canvas drawing and swap buffers (double buffering) */
pub fn end_drawing() {
    unsafe { rl::EndDrawing() };
}

/** Begin 2D mode with custom camera (2D) */
pub fn begin_mode_2_d(camera: Camera2D) {
    unsafe { rl::BeginMode2D(camera) };
}

/** Ends 2D mode with custom camera */
pub fn end_mode_2_d() {
    unsafe { rl::EndMode2D() };
}

/** Begin 3D mode with custom camera (3D) */
pub fn begin_mode_3_d(camera: Camera3D) {
    unsafe { rl::BeginMode3D(camera) };
}

/** Ends 3D mode and returns to default 2D orthographic mode */
pub fn end_mode_3_d() {
    unsafe { rl::EndMode3D() };
}

/** Begin drawing to render texture */
pub fn begin_texture_mode(target: RenderTexture2D) {
    unsafe { rl::BeginTextureMode(target) };
}

/** Ends drawing to render texture */
pub fn end_texture_mode() {
    unsafe { rl::EndTextureMode() };
}

/** Begin custom shader drawing */
pub fn begin_shader_mode(shader: Shader) {
    unsafe { rl::BeginShaderMode(shader) };
}

/** End custom shader drawing (use default shader) */
pub fn end_shader_mode() {
    unsafe { rl::EndShaderMode() };
}

/** Begin blending mode (alpha, additive, multiplied, subtract, custom) */
pub fn begin_blend_mode(mode: c_int) {
    unsafe { rl::BeginBlendMode(mode) };
}

/** End blending mode (reset to default: alpha blending) */
pub fn end_blend_mode() {
    unsafe { rl::EndBlendMode() };
}

/** Begin scissor mode (define screen area for following drawing) */
pub fn begin_scissor_mode(x: c_int, y: c_int, width: c_int, height: c_int) {
    unsafe { rl::BeginScissorMode(x, y, width, height) };
}

/** End scissor mode */
pub fn end_scissor_mode() {
    unsafe { rl::EndScissorMode() };
}

/** Begin stereo rendering (requires VR simulator) */
pub fn begin_vr_stereo_mode(config: VrStereoConfig) {
    unsafe { rl::BeginVrStereoMode(config) };
}

/** End stereo rendering (requires VR simulator) */
pub fn end_vr_stereo_mode() {
    unsafe { rl::EndVrStereoMode() };
}

/** Load VR stereo config for VR simulator device parameters */
pub fn load_vr_stereo_config(device: VrDeviceInfo) -> VrStereoConfig {
    return unsafe { rl::LoadVrStereoConfig(device) };
}

/** Unload VR stereo config */
pub fn unload_vr_stereo_config(config: VrStereoConfig) {
    unsafe { rl::UnloadVrStereoConfig(config) };
}

/** Load shader from files and bind default locations */
pub fn load_shader(vs_file_name: &str, fs_file_name: &str) -> Shader {
    return unsafe { rl::LoadShader(str_to_c_char(vs_file_name), str_to_c_char(fs_file_name)) };
}

/** Load shader from code strings and bind default locations */
pub fn load_shader_from_memory(vs_code: &str, fs_code: &str) -> Shader {
    return unsafe { rl::LoadShaderFromMemory(str_to_c_char(vs_code), str_to_c_char(fs_code)) };
}

/** Check if a shader is ready */
pub fn is_shader_ready(shader: Shader) -> bool {
    return unsafe { rl::IsShaderReady(shader) };
}

/** Get shader uniform location */
pub fn get_shader_location(shader: Shader, uniform_name: &str) -> c_int {
    return unsafe { rl::GetShaderLocation(shader, str_to_c_char(uniform_name)) };
}

/** Get shader attribute location */
pub fn get_shader_location_attrib(shader: Shader, attrib_name: &str) -> c_int {
    return unsafe { rl::GetShaderLocationAttrib(shader, str_to_c_char(attrib_name)) };
}

/** Set shader uniform value */
pub fn set_shader_value(
    shader: Shader,
    loc_index: c_int,
    value: *const c_void,
    uniform_type: c_int,
) {
    unsafe { rl::SetShaderValue(shader, loc_index, value, uniform_type) };
}

/** Set shader uniform value vector */
pub fn set_shader_value_v(
    shader: Shader,
    loc_index: c_int,
    value: *const c_void,
    uniform_type: c_int,
    count: c_int,
) {
    unsafe { rl::SetShaderValueV(shader, loc_index, value, uniform_type, count) };
}

/** Set shader uniform value (matrix 4x4) */
pub fn set_shader_value_matrix(shader: Shader, loc_index: c_int, mat: Matrix) {
    unsafe { rl::SetShaderValueMatrix(shader, loc_index, mat) };
}

/** Set shader uniform value for texture (sampler2d) */
pub fn set_shader_value_texture(shader: Shader, loc_index: c_int, texture: Texture2D) {
    unsafe { rl::SetShaderValueTexture(shader, loc_index, texture) };
}

/** Unload shader from GPU memory (VRAM) */
pub fn unload_shader(shader: Shader) {
    unsafe { rl::UnloadShader(shader) };
}

/** Get a ray trace from mouse position */
pub fn get_mouse_ray(mouse_position: Vector2, camera: Camera) -> Ray {
    return unsafe { rl::GetMouseRay(mouse_position, camera) };
}

/** Get camera transform matrix (view matrix) */
pub fn get_camera_matrix(camera: Camera) -> Matrix {
    return unsafe { rl::GetCameraMatrix(camera) };
}

/** Get camera 2d transform matrix */
pub fn get_camera_matrix_2_d(camera: Camera2D) -> Matrix {
    return unsafe { rl::GetCameraMatrix2D(camera) };
}

/** Get the screen space position for a 3d world space position */
pub fn get_world_to_screen(position: Vector3, camera: Camera) -> Vector2 {
    return unsafe { rl::GetWorldToScreen(position, camera) };
}

/** Get the world space position for a 2d camera screen space position */
pub fn get_screen_to_world_2_d(position: Vector2, camera: Camera2D) -> Vector2 {
    return unsafe { rl::GetScreenToWorld2D(position, camera) };
}

/** Get size position for a 3d world space position */
pub fn get_world_to_screen_ex(
    position: Vector3,
    camera: Camera,
    width: c_int,
    height: c_int,
) -> Vector2 {
    return unsafe { rl::GetWorldToScreenEx(position, camera, width, height) };
}

/** Get the screen space position for a 2d camera world space position */
pub fn get_world_to_screen_2_d(position: Vector2, camera: Camera2D) -> Vector2 {
    return unsafe { rl::GetWorldToScreen2D(position, camera) };
}

/** Set target FPS (maximum) */
pub fn set_target_fps(fps: c_int) {
    unsafe { rl::SetTargetFPS(fps) };
}

/** Get time in seconds for last frame drawn (delta time) */
pub fn get_frame_time() -> f32 {
    return unsafe { rl::GetFrameTime() };
}

/** Get elapsed time in seconds since InitWindow() */
pub fn get_time() -> f64 {
    return unsafe { rl::GetTime() };
}

/** Get current FPS */
pub fn get_fps() -> c_int {
    return unsafe { rl::GetFPS() };
}

/** Swap back buffer with front buffer (screen drawing) */
pub fn swap_screen_buffer() {
    unsafe { rl::SwapScreenBuffer() };
}

/** Register all input events */
pub fn poll_input_events() {
    unsafe { rl::PollInputEvents() };
}

/** Wait for some time (halt program execution) */
pub fn wait_time(seconds: f64) {
    unsafe { rl::WaitTime(seconds) };
}

/** Set the seed for the random number generator */
pub fn set_random_seed(seed: c_uint) {
    unsafe { rl::SetRandomSeed(seed) };
}

/** Get a random value between min and max (both included) */
pub fn get_random_value(min: c_int, max: c_int) -> c_int {
    return unsafe { rl::GetRandomValue(min, max) };
}

/** Load random values sequence, no values repeated */
pub fn load_random_sequence(count: c_uint, min: c_int, max: c_int) -> *mut c_int {
    return unsafe { rl::LoadRandomSequence(count, min, max) };
}

/** Unload random values sequence */
pub fn unload_random_sequence(sequence: *mut c_int) {
    unsafe { rl::UnloadRandomSequence(sequence) };
}

/** Takes a screenshot of current screen (filename extension defines format) */
pub fn take_screenshot(file_name: &str) {
    unsafe { rl::TakeScreenshot(str_to_c_char(file_name)) };
}

/** Setup init configuration flags (view FLAGS) */
pub fn set_config_flags(flags: c_uint) {
    unsafe { rl::SetConfigFlags(flags) };
}

/** Open URL with default system browser (if available) */
pub fn open_url(url: &str) {
    unsafe { rl::OpenURL(str_to_c_char(url)) };
}

/** Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...) */
pub fn trace_log(log_level: c_int, text: &str) {
    unsafe { rl::TraceLog(log_level, str_to_c_char(text)) };
}

/** Set the current threshold (minimum) log level */
pub fn set_trace_log_level(log_level: c_int) {
    unsafe { rl::SetTraceLogLevel(log_level) };
}

/** Internal memory allocator */
pub fn mem_alloc(size: c_uint) -> *mut c_void {
    return unsafe { rl::MemAlloc(size) };
}

/** Internal memory reallocator */
pub fn mem_realloc(ptr: *mut c_void, size: c_uint) -> *mut c_void {
    return unsafe { rl::MemRealloc(ptr, size) };
}

/** Internal memory free */
pub fn mem_free(ptr: *mut c_void) {
    unsafe { rl::MemFree(ptr) };
}

/** Set custom trace log */
pub fn set_trace_log_callback(callback: TraceLogCallback) {
    unsafe { rl::SetTraceLogCallback(callback) };
}

/** Set custom file binary data loader */
pub fn set_load_file_data_callback(callback: LoadFileDataCallback) {
    unsafe { rl::SetLoadFileDataCallback(callback) };
}

/** Set custom file binary data saver */
pub fn set_save_file_data_callback(callback: SaveFileDataCallback) {
    unsafe { rl::SetSaveFileDataCallback(callback) };
}

/** Set custom file text data loader */
pub fn set_load_file_text_callback(callback: LoadFileTextCallback) {
    unsafe { rl::SetLoadFileTextCallback(callback) };
}

/** Set custom file text data saver */
pub fn set_save_file_text_callback(callback: SaveFileTextCallback) {
    unsafe { rl::SetSaveFileTextCallback(callback) };
}

/** Load file data as byte array (read) */
pub fn load_file_data(file_name: &str, data_size: *mut c_int) -> *mut c_uchar {
    return unsafe { rl::LoadFileData(str_to_c_char(file_name), data_size) };
}

/** Unload file data allocated by LoadFileData() */
pub fn unload_file_data(data: *mut c_uchar) {
    unsafe { rl::UnloadFileData(data) };
}

/** Save data to file from byte array (write), returns true on success */
pub fn save_file_data(file_name: &str, data: *mut c_void, data_size: c_int) -> bool {
    return unsafe { rl::SaveFileData(str_to_c_char(file_name), data, data_size) };
}

/** Export data to code (.h), returns true on success */
pub fn export_data_as_code(data: *const c_uchar, data_size: c_int, file_name: &str) -> bool {
    return unsafe { rl::ExportDataAsCode(data, data_size, str_to_c_char(file_name)) };
}

/** Load text data from file (read), returns a '\0' terminated string */
pub fn load_file_text(file_name: &str) -> *mut c_char {
    return unsafe { rl::LoadFileText(str_to_c_char(file_name)) };
}

/** Unload file text data allocated by LoadFileText() */
pub fn unload_file_text(text: *mut c_char) {
    unsafe { rl::UnloadFileText(text) };
}

/** Save text data to file (write), string must be '\0' terminated, returns true on success */
pub fn save_file_text(file_name: &str, text: *mut c_char) -> bool {
    return unsafe { rl::SaveFileText(str_to_c_char(file_name), text) };
}

/** Check if file exists */
pub fn file_exists(file_name: &str) -> bool {
    return unsafe { rl::FileExists(str_to_c_char(file_name)) };
}

/** Check if a directory path exists */
pub fn directory_exists(dir_path: &str) -> bool {
    return unsafe { rl::DirectoryExists(str_to_c_char(dir_path)) };
}

/** Check file extension (including point: .png, .wav) */
pub fn is_file_extension(file_name: &str, ext: &str) -> bool {
    return unsafe { rl::IsFileExtension(str_to_c_char(file_name), str_to_c_char(ext)) };
}

/** Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h) */
pub fn get_file_length(file_name: &str) -> c_int {
    return unsafe { rl::GetFileLength(str_to_c_char(file_name)) };
}

/** Get pointer to extension for a filename string (includes dot: '.png') */
pub fn get_file_extension(file_name: &str) -> String {
    return unsafe { CStr::from_ptr(rl::GetFileExtension(str_to_c_char(file_name))) }
        .to_string_lossy()
        .into();
}

/** Get pointer to filename for a path string */
pub fn get_file_name(file_path: &str) -> String {
    return unsafe { CStr::from_ptr(rl::GetFileName(str_to_c_char(file_path))) }
        .to_string_lossy()
        .into();
}

/** Get filename string without extension (uses static string) */
pub fn get_file_name_without_ext(file_path: &str) -> String {
    return unsafe { CStr::from_ptr(rl::GetFileNameWithoutExt(str_to_c_char(file_path))) }
        .to_string_lossy()
        .into();
}

/** Get full path for a given fileName with path (uses static string) */
pub fn get_directory_path(file_path: &str) -> String {
    return unsafe { CStr::from_ptr(rl::GetDirectoryPath(str_to_c_char(file_path))) }
        .to_string_lossy()
        .into();
}

/** Get previous directory path for a given path (uses static string) */
pub fn get_prev_directory_path(dir_path: &str) -> String {
    return unsafe { CStr::from_ptr(rl::GetPrevDirectoryPath(str_to_c_char(dir_path))) }
        .to_string_lossy()
        .into();
}

/** Get current working directory (uses static string) */
pub fn get_working_directory() -> String {
    return unsafe { CStr::from_ptr(rl::GetWorkingDirectory()) }
        .to_string_lossy()
        .into();
}

/** Get the directory of the running application (uses static string) */
pub fn get_application_directory() -> String {
    return unsafe { CStr::from_ptr(rl::GetApplicationDirectory()) }
        .to_string_lossy()
        .into();
}

/** Change working directory, return true on success */
pub fn change_directory(dir: &str) -> bool {
    return unsafe { rl::ChangeDirectory(str_to_c_char(dir)) };
}

/** Check if a given path is a file or a directory */
pub fn is_path_file(path: &str) -> bool {
    return unsafe { rl::IsPathFile(str_to_c_char(path)) };
}

/** Load directory filepaths */
pub fn load_directory_files(dir_path: &str) -> FilePathList {
    return unsafe { rl::LoadDirectoryFiles(str_to_c_char(dir_path)) };
}

/** Load directory filepaths with extension filtering and recursive directory scan */
pub fn load_directory_files_ex(base_path: &str, filter: &str, scan_subdirs: bool) -> FilePathList {
    return unsafe {
        rl::LoadDirectoryFilesEx(
            str_to_c_char(base_path),
            str_to_c_char(filter),
            scan_subdirs,
        )
    };
}

/** Unload filepaths */
pub fn unload_directory_files(files: FilePathList) {
    unsafe { rl::UnloadDirectoryFiles(files) };
}

/** Check if a file has been dropped into window */
pub fn is_file_dropped() -> bool {
    return unsafe { rl::IsFileDropped() };
}

/** Load dropped filepaths */
pub fn load_dropped_files() -> FilePathList {
    return unsafe { rl::LoadDroppedFiles() };
}

/** Unload dropped filepaths */
pub fn unload_dropped_files(files: FilePathList) {
    unsafe { rl::UnloadDroppedFiles(files) };
}

/** Get file modification time (last write time) */
pub fn get_file_mod_time(file_name: &str) -> c_long {
    return unsafe { rl::GetFileModTime(str_to_c_char(file_name)) };
}

/** Compress data (DEFLATE algorithm), memory must be MemFree() */
pub fn compress_data(
    data: *const c_uchar,
    data_size: c_int,
    comp_data_size: *mut c_int,
) -> *mut c_uchar {
    return unsafe { rl::CompressData(data, data_size, comp_data_size) };
}

/** Decompress data (DEFLATE algorithm), memory must be MemFree() */
pub fn decompress_data(
    comp_data: *const c_uchar,
    comp_data_size: c_int,
    data_size: *mut c_int,
) -> *mut c_uchar {
    return unsafe { rl::DecompressData(comp_data, comp_data_size, data_size) };
}

/** Encode data to Base64 string, memory must be MemFree() */
pub fn encode_data_base_64(
    data: *const c_uchar,
    data_size: c_int,
    output_size: *mut c_int,
) -> *mut c_char {
    return unsafe { rl::EncodeDataBase64(data, data_size, output_size) };
}

/** Decode Base64 string data, memory must be MemFree() */
pub fn decode_data_base_64(data: *const c_uchar, output_size: *mut c_int) -> *mut c_uchar {
    return unsafe { rl::DecodeDataBase64(data, output_size) };
}

/** Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS */
pub fn load_automation_event_list(file_name: &str) -> AutomationEventList {
    return unsafe { rl::LoadAutomationEventList(str_to_c_char(file_name)) };
}

/** Unload automation events list from file */
pub fn unload_automation_event_list(list: *mut AutomationEventList) {
    unsafe { rl::UnloadAutomationEventList(list) };
}

/** Export automation events list as text file */
pub fn export_automation_event_list(list: AutomationEventList, file_name: &str) -> bool {
    return unsafe { rl::ExportAutomationEventList(list, str_to_c_char(file_name)) };
}

/** Set automation event list to record to */
pub fn set_automation_event_list(list: *mut AutomationEventList) {
    unsafe { rl::SetAutomationEventList(list) };
}

/** Set automation event internal base frame to start recording */
pub fn set_automation_event_base_frame(frame: c_int) {
    unsafe { rl::SetAutomationEventBaseFrame(frame) };
}

/** Start recording automation events (AutomationEventList must be set) */
pub fn start_automation_event_recording() {
    unsafe { rl::StartAutomationEventRecording() };
}

/** Stop recording automation events */
pub fn stop_automation_event_recording() {
    unsafe { rl::StopAutomationEventRecording() };
}

/** Play a recorded automation event */
pub fn play_automation_event(event: AutomationEvent) {
    unsafe { rl::PlayAutomationEvent(event) };
}

/** Check if a key has been pressed once */
pub fn is_key_pressed(key: c_int) -> bool {
    return unsafe { rl::IsKeyPressed(key) };
}

/** Check if a key has been pressed again (Only PLATFORM_DESKTOP) */
pub fn is_key_pressed_repeat(key: c_int) -> bool {
    return unsafe { rl::IsKeyPressedRepeat(key) };
}

/** Check if a key is being pressed */
pub fn is_key_down(key: c_int) -> bool {
    return unsafe { rl::IsKeyDown(key) };
}

/** Check if a key has been released once */
pub fn is_key_released(key: c_int) -> bool {
    return unsafe { rl::IsKeyReleased(key) };
}

/** Check if a key is NOT being pressed */
pub fn is_key_up(key: c_int) -> bool {
    return unsafe { rl::IsKeyUp(key) };
}

/** Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty */
pub fn get_key_pressed() -> c_int {
    return unsafe { rl::GetKeyPressed() };
}

/** Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty */
pub fn get_char_pressed() -> c_int {
    return unsafe { rl::GetCharPressed() };
}

/** Set a custom key to exit program (default is ESC) */
pub fn set_exit_key(key: c_int) {
    unsafe { rl::SetExitKey(key) };
}

/** Check if a gamepad is available */
pub fn is_gamepad_available(gamepad: c_int) -> bool {
    return unsafe { rl::IsGamepadAvailable(gamepad) };
}

/** Get gamepad internal name id */
pub fn get_gamepad_name(gamepad: c_int) -> String {
    return unsafe { CStr::from_ptr(rl::GetGamepadName(gamepad)) }
        .to_string_lossy()
        .into();
}

/** Check if a gamepad button has been pressed once */
pub fn is_gamepad_button_pressed(gamepad: c_int, button: c_int) -> bool {
    return unsafe { rl::IsGamepadButtonPressed(gamepad, button) };
}

/** Check if a gamepad button is being pressed */
pub fn is_gamepad_button_down(gamepad: c_int, button: c_int) -> bool {
    return unsafe { rl::IsGamepadButtonDown(gamepad, button) };
}

/** Check if a gamepad button has been released once */
pub fn is_gamepad_button_released(gamepad: c_int, button: c_int) -> bool {
    return unsafe { rl::IsGamepadButtonReleased(gamepad, button) };
}

/** Check if a gamepad button is NOT being pressed */
pub fn is_gamepad_button_up(gamepad: c_int, button: c_int) -> bool {
    return unsafe { rl::IsGamepadButtonUp(gamepad, button) };
}

/** Get the last gamepad button pressed */
pub fn get_gamepad_button_pressed() -> c_int {
    return unsafe { rl::GetGamepadButtonPressed() };
}

/** Get gamepad axis count for a gamepad */
pub fn get_gamepad_axis_count(gamepad: c_int) -> c_int {
    return unsafe { rl::GetGamepadAxisCount(gamepad) };
}

/** Get axis movement value for a gamepad axis */
pub fn get_gamepad_axis_movement(gamepad: c_int, axis: c_int) -> f32 {
    return unsafe { rl::GetGamepadAxisMovement(gamepad, axis) };
}

/** Set internal gamepad mappings (SDL_GameControllerDB) */
pub fn set_gamepad_mappings(mappings: &str) -> c_int {
    return unsafe { rl::SetGamepadMappings(str_to_c_char(mappings)) };
}

/** Check if a mouse button has been pressed once */
pub fn is_mouse_button_pressed(button: c_int) -> bool {
    return unsafe { rl::IsMouseButtonPressed(button) };
}

/** Check if a mouse button is being pressed */
pub fn is_mouse_button_down(button: c_int) -> bool {
    return unsafe { rl::IsMouseButtonDown(button) };
}

/** Check if a mouse button has been released once */
pub fn is_mouse_button_released(button: c_int) -> bool {
    return unsafe { rl::IsMouseButtonReleased(button) };
}

/** Check if a mouse button is NOT being pressed */
pub fn is_mouse_button_up(button: c_int) -> bool {
    return unsafe { rl::IsMouseButtonUp(button) };
}

/** Get mouse position X */
pub fn get_mouse_x() -> c_int {
    return unsafe { rl::GetMouseX() };
}

/** Get mouse position Y */
pub fn get_mouse_y() -> c_int {
    return unsafe { rl::GetMouseY() };
}

/** Get mouse position XY */
pub fn get_mouse_position() -> Vector2 {
    return unsafe { rl::GetMousePosition() };
}

/** Get mouse delta between frames */
pub fn get_mouse_delta() -> Vector2 {
    return unsafe { rl::GetMouseDelta() };
}

/** Set mouse position XY */
pub fn set_mouse_position(x: c_int, y: c_int) {
    unsafe { rl::SetMousePosition(x, y) };
}

/** Set mouse offset */
pub fn set_mouse_offset(offset_x: c_int, offset_y: c_int) {
    unsafe { rl::SetMouseOffset(offset_x, offset_y) };
}

/** Set mouse scaling */
pub fn set_mouse_scale(scale_x: f32, scale_y: f32) {
    unsafe { rl::SetMouseScale(scale_x, scale_y) };
}

/** Get mouse wheel movement for X or Y, whichever is larger */
pub fn get_mouse_wheel_move() -> f32 {
    return unsafe { rl::GetMouseWheelMove() };
}

/** Get mouse wheel movement for both X and Y */
pub fn get_mouse_wheel_move_v() -> Vector2 {
    return unsafe { rl::GetMouseWheelMoveV() };
}

/** Set mouse cursor */
pub fn set_mouse_cursor(cursor: c_int) {
    unsafe { rl::SetMouseCursor(cursor) };
}

/** Get touch position X for touch point 0 (relative to screen size) */
pub fn get_touch_x() -> c_int {
    return unsafe { rl::GetTouchX() };
}

/** Get touch position Y for touch point 0 (relative to screen size) */
pub fn get_touch_y() -> c_int {
    return unsafe { rl::GetTouchY() };
}

/** Get touch position XY for a touch point index (relative to screen size) */
pub fn get_touch_position(index: c_int) -> Vector2 {
    return unsafe { rl::GetTouchPosition(index) };
}

/** Get touch point identifier for given index */
pub fn get_touch_point_id(index: c_int) -> c_int {
    return unsafe { rl::GetTouchPointId(index) };
}

/** Get number of touch points */
pub fn get_touch_point_count() -> c_int {
    return unsafe { rl::GetTouchPointCount() };
}

/** Enable a set of gestures using flags */
pub fn set_gestures_enabled(flags: c_uint) {
    unsafe { rl::SetGesturesEnabled(flags) };
}

/** Check if a gesture have been detected */
pub fn is_gesture_detected(gesture: c_uint) -> bool {
    return unsafe { rl::IsGestureDetected(gesture) };
}

/** Get latest detected gesture */
pub fn get_gesture_detected() -> c_int {
    return unsafe { rl::GetGestureDetected() };
}

/** Get gesture hold time in milliseconds */
pub fn get_gesture_hold_duration() -> f32 {
    return unsafe { rl::GetGestureHoldDuration() };
}

/** Get gesture drag vector */
pub fn get_gesture_drag_vector() -> Vector2 {
    return unsafe { rl::GetGestureDragVector() };
}

/** Get gesture drag angle */
pub fn get_gesture_drag_angle() -> f32 {
    return unsafe { rl::GetGestureDragAngle() };
}

/** Get gesture pinch delta */
pub fn get_gesture_pinch_vector() -> Vector2 {
    return unsafe { rl::GetGesturePinchVector() };
}

/** Get gesture pinch angle */
pub fn get_gesture_pinch_angle() -> f32 {
    return unsafe { rl::GetGesturePinchAngle() };
}

/** Update camera position for selected mode */
pub fn update_camera(camera: *mut Camera, mode: c_int) {
    unsafe { rl::UpdateCamera(camera, mode) };
}

/** Update camera movement/rotation */
pub fn update_camera_pro(camera: *mut Camera, movement: Vector3, rotation: Vector3, zoom: f32) {
    unsafe { rl::UpdateCameraPro(camera, movement, rotation, zoom) };
}

/** Set texture and rectangle to be used on shapes drawing */
pub fn set_shapes_texture(texture: Texture2D, source: Rectangle) {
    unsafe { rl::SetShapesTexture(texture, source) };
}

/** Draw a pixel */
pub fn draw_pixel(pos_x: c_int, pos_y: c_int, color: Color) {
    unsafe { rl::DrawPixel(pos_x, pos_y, color) };
}

/** Draw a pixel (Vector version) */
pub fn draw_pixel_v(position: Vector2, color: Color) {
    unsafe { rl::DrawPixelV(position, color) };
}

/** Draw a line */
pub fn draw_line(
    start_pos_x: c_int,
    start_pos_y: c_int,
    end_pos_x: c_int,
    end_pos_y: c_int,
    color: Color,
) {
    unsafe { rl::DrawLine(start_pos_x, start_pos_y, end_pos_x, end_pos_y, color) };
}

/** Draw a line (using gl lines) */
pub fn draw_line_v(start_pos: Vector2, end_pos: Vector2, color: Color) {
    unsafe { rl::DrawLineV(start_pos, end_pos, color) };
}

/** Draw a line (using triangles/quads) */
pub fn draw_line_ex(start_pos: Vector2, end_pos: Vector2, thick: f32, color: Color) {
    unsafe { rl::DrawLineEx(start_pos, end_pos, thick, color) };
}

/** Draw lines sequence (using gl lines) */
pub fn draw_line_strip(points: *mut Vector2, point_count: c_int, color: Color) {
    unsafe { rl::DrawLineStrip(points, point_count, color) };
}

/** Draw line segment cubic-bezier in-out interpolation */
pub fn draw_line_bezier(start_pos: Vector2, end_pos: Vector2, thick: f32, color: Color) {
    unsafe { rl::DrawLineBezier(start_pos, end_pos, thick, color) };
}

/** Draw a color-filled circle */
pub fn draw_circle(center_x: c_int, center_y: c_int, radius: f32, color: Color) {
    unsafe { rl::DrawCircle(center_x, center_y, radius, color) };
}

/** Draw a piece of a circle */
pub fn draw_circle_sector(
    center: Vector2,
    radius: f32,
    start_angle: f32,
    end_angle: f32,
    segments: c_int,
    color: Color,
) {
    unsafe { rl::DrawCircleSector(center, radius, start_angle, end_angle, segments, color) };
}

/** Draw circle sector outline */
pub fn draw_circle_sector_lines(
    center: Vector2,
    radius: f32,
    start_angle: f32,
    end_angle: f32,
    segments: c_int,
    color: Color,
) {
    unsafe { rl::DrawCircleSectorLines(center, radius, start_angle, end_angle, segments, color) };
}

/** Draw a gradient-filled circle */
pub fn draw_circle_gradient(
    center_x: c_int,
    center_y: c_int,
    radius: f32,
    color_1: Color,
    color_2: Color,
) {
    unsafe { rl::DrawCircleGradient(center_x, center_y, radius, color_1, color_2) };
}

/** Draw a color-filled circle (Vector version) */
pub fn draw_circle_v(center: Vector2, radius: f32, color: Color) {
    unsafe { rl::DrawCircleV(center, radius, color) };
}

/** Draw circle outline */
pub fn draw_circle_lines(center_x: c_int, center_y: c_int, radius: f32, color: Color) {
    unsafe { rl::DrawCircleLines(center_x, center_y, radius, color) };
}

/** Draw circle outline (Vector version) */
pub fn draw_circle_lines_v(center: Vector2, radius: f32, color: Color) {
    unsafe { rl::DrawCircleLinesV(center, radius, color) };
}

/** Draw ellipse */
pub fn draw_ellipse(center_x: c_int, center_y: c_int, radius_h: f32, radius_v: f32, color: Color) {
    unsafe { rl::DrawEllipse(center_x, center_y, radius_h, radius_v, color) };
}

/** Draw ellipse outline */
pub fn draw_ellipse_lines(
    center_x: c_int,
    center_y: c_int,
    radius_h: f32,
    radius_v: f32,
    color: Color,
) {
    unsafe { rl::DrawEllipseLines(center_x, center_y, radius_h, radius_v, color) };
}

/** Draw ring */
pub fn draw_ring(
    center: Vector2,
    inner_radius: f32,
    outer_radius: f32,
    start_angle: f32,
    end_angle: f32,
    segments: c_int,
    color: Color,
) {
    unsafe {
        rl::DrawRing(
            center,
            inner_radius,
            outer_radius,
            start_angle,
            end_angle,
            segments,
            color,
        )
    };
}

/** Draw ring outline */
pub fn draw_ring_lines(
    center: Vector2,
    inner_radius: f32,
    outer_radius: f32,
    start_angle: f32,
    end_angle: f32,
    segments: c_int,
    color: Color,
) {
    unsafe {
        rl::DrawRingLines(
            center,
            inner_radius,
            outer_radius,
            start_angle,
            end_angle,
            segments,
            color,
        )
    };
}

/** Draw a color-filled rectangle */
pub fn draw_rectangle(pos_x: c_int, pos_y: c_int, width: c_int, height: c_int, color: Color) {
    unsafe { rl::DrawRectangle(pos_x, pos_y, width, height, color) };
}

/** Draw a color-filled rectangle (Vector version) */
pub fn draw_rectangle_v(position: Vector2, size: Vector2, color: Color) {
    unsafe { rl::DrawRectangleV(position, size, color) };
}

/** Draw a color-filled rectangle */
pub fn draw_rectangle_rec(rec: Rectangle, color: Color) {
    unsafe { rl::DrawRectangleRec(rec, color) };
}

/** Draw a color-filled rectangle with pro parameters */
pub fn draw_rectangle_pro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color) {
    unsafe { rl::DrawRectanglePro(rec, origin, rotation, color) };
}

/** Draw a vertical-gradient-filled rectangle */
pub fn draw_rectangle_gradient_v(
    pos_x: c_int,
    pos_y: c_int,
    width: c_int,
    height: c_int,
    color_1: Color,
    color_2: Color,
) {
    unsafe { rl::DrawRectangleGradientV(pos_x, pos_y, width, height, color_1, color_2) };
}

/** Draw a horizontal-gradient-filled rectangle */
pub fn draw_rectangle_gradient_h(
    pos_x: c_int,
    pos_y: c_int,
    width: c_int,
    height: c_int,
    color_1: Color,
    color_2: Color,
) {
    unsafe { rl::DrawRectangleGradientH(pos_x, pos_y, width, height, color_1, color_2) };
}

/** Draw a gradient-filled rectangle with custom vertex colors */
pub fn draw_rectangle_gradient_ex(
    rec: Rectangle,
    col_1: Color,
    col_2: Color,
    col_3: Color,
    col_4: Color,
) {
    unsafe { rl::DrawRectangleGradientEx(rec, col_1, col_2, col_3, col_4) };
}

/** Draw rectangle outline */
pub fn draw_rectangle_lines(pos_x: c_int, pos_y: c_int, width: c_int, height: c_int, color: Color) {
    unsafe { rl::DrawRectangleLines(pos_x, pos_y, width, height, color) };
}

/** Draw rectangle outline with extended parameters */
pub fn draw_rectangle_lines_ex(rec: Rectangle, line_thick: f32, color: Color) {
    unsafe { rl::DrawRectangleLinesEx(rec, line_thick, color) };
}

/** Draw rectangle with rounded edges */
pub fn draw_rectangle_rounded(rec: Rectangle, roundness: f32, segments: c_int, color: Color) {
    unsafe { rl::DrawRectangleRounded(rec, roundness, segments, color) };
}

/** Draw rectangle with rounded edges outline */
pub fn draw_rectangle_rounded_lines(
    rec: Rectangle,
    roundness: f32,
    segments: c_int,
    line_thick: f32,
    color: Color,
) {
    unsafe { rl::DrawRectangleRoundedLines(rec, roundness, segments, line_thick, color) };
}

/** Draw a color-filled triangle (vertex in counter-clockwise order!) */
pub fn draw_triangle(v_1: Vector2, v_2: Vector2, v_3: Vector2, color: Color) {
    unsafe { rl::DrawTriangle(v_1, v_2, v_3, color) };
}

/** Draw triangle outline (vertex in counter-clockwise order!) */
pub fn draw_triangle_lines(v_1: Vector2, v_2: Vector2, v_3: Vector2, color: Color) {
    unsafe { rl::DrawTriangleLines(v_1, v_2, v_3, color) };
}

/** Draw a triangle fan defined by points (first vertex is the center) */
pub fn draw_triangle_fan(points: *mut Vector2, point_count: c_int, color: Color) {
    unsafe { rl::DrawTriangleFan(points, point_count, color) };
}

/** Draw a triangle strip defined by points */
pub fn draw_triangle_strip(points: *mut Vector2, point_count: c_int, color: Color) {
    unsafe { rl::DrawTriangleStrip(points, point_count, color) };
}

/** Draw a regular polygon (Vector version) */
pub fn draw_poly(center: Vector2, sides: c_int, radius: f32, rotation: f32, color: Color) {
    unsafe { rl::DrawPoly(center, sides, radius, rotation, color) };
}

/** Draw a polygon outline of n sides */
pub fn draw_poly_lines(center: Vector2, sides: c_int, radius: f32, rotation: f32, color: Color) {
    unsafe { rl::DrawPolyLines(center, sides, radius, rotation, color) };
}

/** Draw a polygon outline of n sides with extended parameters */
pub fn draw_poly_lines_ex(
    center: Vector2,
    sides: c_int,
    radius: f32,
    rotation: f32,
    line_thick: f32,
    color: Color,
) {
    unsafe { rl::DrawPolyLinesEx(center, sides, radius, rotation, line_thick, color) };
}

/** Draw spline: Linear, minimum 2 points */
pub fn draw_spline_linear(points: *mut Vector2, point_count: c_int, thick: f32, color: Color) {
    unsafe { rl::DrawSplineLinear(points, point_count, thick, color) };
}

/** Draw spline: B-Spline, minimum 4 points */
pub fn draw_spline_basis(points: *mut Vector2, point_count: c_int, thick: f32, color: Color) {
    unsafe { rl::DrawSplineBasis(points, point_count, thick, color) };
}

/** Draw spline: Catmull-Rom, minimum 4 points */
pub fn draw_spline_catmull_rom(points: *mut Vector2, point_count: c_int, thick: f32, color: Color) {
    unsafe { rl::DrawSplineCatmullRom(points, point_count, thick, color) };
}

/** Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...] */
pub fn draw_spline_bezier_quadratic(
    points: *mut Vector2,
    point_count: c_int,
    thick: f32,
    color: Color,
) {
    unsafe { rl::DrawSplineBezierQuadratic(points, point_count, thick, color) };
}

/** Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...] */
pub fn draw_spline_bezier_cubic(
    points: *mut Vector2,
    point_count: c_int,
    thick: f32,
    color: Color,
) {
    unsafe { rl::DrawSplineBezierCubic(points, point_count, thick, color) };
}

/** Draw spline segment: Linear, 2 points */
pub fn draw_spline_segment_linear(p_1: Vector2, p_2: Vector2, thick: f32, color: Color) {
    unsafe { rl::DrawSplineSegmentLinear(p_1, p_2, thick, color) };
}

/** Draw spline segment: B-Spline, 4 points */
pub fn draw_spline_segment_basis(
    p_1: Vector2,
    p_2: Vector2,
    p_3: Vector2,
    p_4: Vector2,
    thick: f32,
    color: Color,
) {
    unsafe { rl::DrawSplineSegmentBasis(p_1, p_2, p_3, p_4, thick, color) };
}

/** Draw spline segment: Catmull-Rom, 4 points */
pub fn draw_spline_segment_catmull_rom(
    p_1: Vector2,
    p_2: Vector2,
    p_3: Vector2,
    p_4: Vector2,
    thick: f32,
    color: Color,
) {
    unsafe { rl::DrawSplineSegmentCatmullRom(p_1, p_2, p_3, p_4, thick, color) };
}

/** Draw spline segment: Quadratic Bezier, 2 points, 1 control point */
pub fn draw_spline_segment_bezier_quadratic(
    p_1: Vector2,
    c_2: Vector2,
    p_3: Vector2,
    thick: f32,
    color: Color,
) {
    unsafe { rl::DrawSplineSegmentBezierQuadratic(p_1, c_2, p_3, thick, color) };
}

/** Draw spline segment: Cubic Bezier, 2 points, 2 control points */
pub fn draw_spline_segment_bezier_cubic(
    p_1: Vector2,
    c_2: Vector2,
    c_3: Vector2,
    p_4: Vector2,
    thick: f32,
    color: Color,
) {
    unsafe { rl::DrawSplineSegmentBezierCubic(p_1, c_2, c_3, p_4, thick, color) };
}

/** Get (evaluate) spline point: Linear */
pub fn get_spline_point_linear(start_pos: Vector2, end_pos: Vector2, t: f32) -> Vector2 {
    return unsafe { rl::GetSplinePointLinear(start_pos, end_pos, t) };
}

/** Get (evaluate) spline point: B-Spline */
pub fn get_spline_point_basis(
    p_1: Vector2,
    p_2: Vector2,
    p_3: Vector2,
    p_4: Vector2,
    t: f32,
) -> Vector2 {
    return unsafe { rl::GetSplinePointBasis(p_1, p_2, p_3, p_4, t) };
}

/** Get (evaluate) spline point: Catmull-Rom */
pub fn get_spline_point_catmull_rom(
    p_1: Vector2,
    p_2: Vector2,
    p_3: Vector2,
    p_4: Vector2,
    t: f32,
) -> Vector2 {
    return unsafe { rl::GetSplinePointCatmullRom(p_1, p_2, p_3, p_4, t) };
}

/** Get (evaluate) spline point: Quadratic Bezier */
pub fn get_spline_point_bezier_quad(p_1: Vector2, c_2: Vector2, p_3: Vector2, t: f32) -> Vector2 {
    return unsafe { rl::GetSplinePointBezierQuad(p_1, c_2, p_3, t) };
}

/** Get (evaluate) spline point: Cubic Bezier */
pub fn get_spline_point_bezier_cubic(
    p_1: Vector2,
    c_2: Vector2,
    c_3: Vector2,
    p_4: Vector2,
    t: f32,
) -> Vector2 {
    return unsafe { rl::GetSplinePointBezierCubic(p_1, c_2, c_3, p_4, t) };
}

/** Check collision between two rectangles */
pub fn check_collision_recs(rec_1: Rectangle, rec_2: Rectangle) -> bool {
    return unsafe { rl::CheckCollisionRecs(rec_1, rec_2) };
}

/** Check collision between two circles */
pub fn check_collision_circles(
    center_1: Vector2,
    radius_1: f32,
    center_2: Vector2,
    radius_2: f32,
) -> bool {
    return unsafe { rl::CheckCollisionCircles(center_1, radius_1, center_2, radius_2) };
}

/** Check collision between circle and rectangle */
pub fn check_collision_circle_rec(center: Vector2, radius: f32, rec: Rectangle) -> bool {
    return unsafe { rl::CheckCollisionCircleRec(center, radius, rec) };
}

/** Check if point is inside rectangle */
pub fn check_collision_point_rec(point: Vector2, rec: Rectangle) -> bool {
    return unsafe { rl::CheckCollisionPointRec(point, rec) };
}

/** Check if point is inside circle */
pub fn check_collision_point_circle(point: Vector2, center: Vector2, radius: f32) -> bool {
    return unsafe { rl::CheckCollisionPointCircle(point, center, radius) };
}

/** Check if point is inside a triangle */
pub fn check_collision_point_triangle(
    point: Vector2,
    p_1: Vector2,
    p_2: Vector2,
    p_3: Vector2,
) -> bool {
    return unsafe { rl::CheckCollisionPointTriangle(point, p_1, p_2, p_3) };
}

/** Check if point is within a polygon described by array of vertices */
pub fn check_collision_point_poly(
    point: Vector2,
    points: *mut Vector2,
    point_count: c_int,
) -> bool {
    return unsafe { rl::CheckCollisionPointPoly(point, points, point_count) };
}

/** Check the collision between two lines defined by two points each, returns collision point by reference */
pub fn check_collision_lines(
    start_pos_1: Vector2,
    end_pos_1: Vector2,
    start_pos_2: Vector2,
    end_pos_2: Vector2,
    collision_point: *mut Vector2,
) -> bool {
    return unsafe {
        rl::CheckCollisionLines(
            start_pos_1,
            end_pos_1,
            start_pos_2,
            end_pos_2,
            collision_point,
        )
    };
}

/** Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold] */
pub fn check_collision_point_line(
    point: Vector2,
    p_1: Vector2,
    p_2: Vector2,
    threshold: c_int,
) -> bool {
    return unsafe { rl::CheckCollisionPointLine(point, p_1, p_2, threshold) };
}

/** Get collision rectangle for two rectangles collision */
pub fn get_collision_rec(rec_1: Rectangle, rec_2: Rectangle) -> Rectangle {
    return unsafe { rl::GetCollisionRec(rec_1, rec_2) };
}

/** Load image from file into CPU memory (RAM) */
pub fn load_image(file_name: &str) -> Image {
    return unsafe { rl::LoadImage(str_to_c_char(file_name)) };
}

/** Load image from RAW file data */
pub fn load_image_raw(
    file_name: &str,
    width: c_int,
    height: c_int,
    format: c_int,
    header_size: c_int,
) -> Image {
    return unsafe {
        rl::LoadImageRaw(str_to_c_char(file_name), width, height, format, header_size)
    };
}

/** Load image from SVG file data or string with specified size */
pub fn load_image_svg(file_name_or_string: &str, width: c_int, height: c_int) -> Image {
    return unsafe { rl::LoadImageSvg(str_to_c_char(file_name_or_string), width, height) };
}

/** Load image sequence from file (frames appended to image.data) */
pub fn load_image_anim(file_name: &str, frames: *mut c_int) -> Image {
    return unsafe { rl::LoadImageAnim(str_to_c_char(file_name), frames) };
}

/** Load image from memory buffer, fileType refers to extension: i.e. '.png' */
pub fn load_image_from_memory(
    file_type: &str,
    file_data: *const c_uchar,
    data_size: c_int,
) -> Image {
    return unsafe { rl::LoadImageFromMemory(str_to_c_char(file_type), file_data, data_size) };
}

/** Load image from GPU texture data */
pub fn load_image_from_texture(texture: Texture2D) -> Image {
    return unsafe { rl::LoadImageFromTexture(texture) };
}

/** Load image from screen buffer and (screenshot) */
pub fn load_image_from_screen() -> Image {
    return unsafe { rl::LoadImageFromScreen() };
}

/** Check if an image is ready */
pub fn is_image_ready(image: Image) -> bool {
    return unsafe { rl::IsImageReady(image) };
}

/** Unload image from CPU memory (RAM) */
pub fn unload_image(image: Image) {
    unsafe { rl::UnloadImage(image) };
}

/** Export image data to file, returns true on success */
pub fn export_image(image: Image, file_name: &str) -> bool {
    return unsafe { rl::ExportImage(image, str_to_c_char(file_name)) };
}

/** Export image to memory buffer */
pub fn export_image_to_memory(
    image: Image,
    file_type: &str,
    file_size: *mut c_int,
) -> *mut c_uchar {
    return unsafe { rl::ExportImageToMemory(image, str_to_c_char(file_type), file_size) };
}

/** Export image as code file defining an array of bytes, returns true on success */
pub fn export_image_as_code(image: Image, file_name: &str) -> bool {
    return unsafe { rl::ExportImageAsCode(image, str_to_c_char(file_name)) };
}

/** Generate image: plain color */
pub fn gen_image_color(width: c_int, height: c_int, color: Color) -> Image {
    return unsafe { rl::GenImageColor(width, height, color) };
}

/** Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient */
pub fn gen_image_gradient_linear(
    width: c_int,
    height: c_int,
    direction: c_int,
    start: Color,
    end: Color,
) -> Image {
    return unsafe { rl::GenImageGradientLinear(width, height, direction, start, end) };
}

/** Generate image: radial gradient */
pub fn gen_image_gradient_radial(
    width: c_int,
    height: c_int,
    density: f32,
    inner: Color,
    outer: Color,
) -> Image {
    return unsafe { rl::GenImageGradientRadial(width, height, density, inner, outer) };
}

/** Generate image: square gradient */
pub fn gen_image_gradient_square(
    width: c_int,
    height: c_int,
    density: f32,
    inner: Color,
    outer: Color,
) -> Image {
    return unsafe { rl::GenImageGradientSquare(width, height, density, inner, outer) };
}

/** Generate image: checked */
pub fn gen_image_checked(
    width: c_int,
    height: c_int,
    checks_x: c_int,
    checks_y: c_int,
    col_1: Color,
    col_2: Color,
) -> Image {
    return unsafe { rl::GenImageChecked(width, height, checks_x, checks_y, col_1, col_2) };
}

/** Generate image: white noise */
pub fn gen_image_white_noise(width: c_int, height: c_int, factor: f32) -> Image {
    return unsafe { rl::GenImageWhiteNoise(width, height, factor) };
}

/** Generate image: perlin noise */
pub fn gen_image_perlin_noise(
    width: c_int,
    height: c_int,
    offset_x: c_int,
    offset_y: c_int,
    scale: f32,
) -> Image {
    return unsafe { rl::GenImagePerlinNoise(width, height, offset_x, offset_y, scale) };
}

/** Generate image: cellular algorithm, bigger tileSize means bigger cells */
pub fn gen_image_cellular(width: c_int, height: c_int, tile_size: c_int) -> Image {
    return unsafe { rl::GenImageCellular(width, height, tile_size) };
}

/** Generate image: grayscale image from text data */
pub fn gen_image_text(width: c_int, height: c_int, text: &str) -> Image {
    return unsafe { rl::GenImageText(width, height, str_to_c_char(text)) };
}

/** Create an image duplicate (useful for transformations) */
pub fn image_copy(image: Image) -> Image {
    return unsafe { rl::ImageCopy(image) };
}

/** Create an image from another image piece */
pub fn image_from_image(image: Image, rec: Rectangle) -> Image {
    return unsafe { rl::ImageFromImage(image, rec) };
}

/** Create an image from text (default font) */
pub fn image_text(text: &str, font_size: c_int, color: Color) -> Image {
    return unsafe { rl::ImageText(str_to_c_char(text), font_size, color) };
}

/** Create an image from text (custom sprite font) */
pub fn image_text_ex(font: Font, text: &str, font_size: f32, spacing: f32, tint: Color) -> Image {
    return unsafe { rl::ImageTextEx(font, str_to_c_char(text), font_size, spacing, tint) };
}

/** Convert image data to desired format */
pub fn image_format(image: *mut Image, new_format: c_int) {
    unsafe { rl::ImageFormat(image, new_format) };
}

/** Convert image to POT (power-of-two) */
pub fn image_to_pot(image: *mut Image, fill: Color) {
    unsafe { rl::ImageToPOT(image, fill) };
}

/** Crop an image to a defined rectangle */
pub fn image_crop(image: *mut Image, crop: Rectangle) {
    unsafe { rl::ImageCrop(image, crop) };
}

/** Crop image depending on alpha value */
pub fn image_alpha_crop(image: *mut Image, threshold: f32) {
    unsafe { rl::ImageAlphaCrop(image, threshold) };
}

/** Clear alpha channel to desired color */
pub fn image_alpha_clear(image: *mut Image, color: Color, threshold: f32) {
    unsafe { rl::ImageAlphaClear(image, color, threshold) };
}

/** Apply alpha mask to image */
pub fn image_alpha_mask(image: *mut Image, alpha_mask: Image) {
    unsafe { rl::ImageAlphaMask(image, alpha_mask) };
}

/** Premultiply alpha channel */
pub fn image_alpha_premultiply(image: *mut Image) {
    unsafe { rl::ImageAlphaPremultiply(image) };
}

/** Apply Gaussian blur using a box blur approximation */
pub fn image_blur_gaussian(image: *mut Image, blur_size: c_int) {
    unsafe { rl::ImageBlurGaussian(image, blur_size) };
}

/** Resize image (Bicubic scaling algorithm) */
pub fn image_resize(image: *mut Image, new_width: c_int, new_height: c_int) {
    unsafe { rl::ImageResize(image, new_width, new_height) };
}

/** Resize image (Nearest-Neighbor scaling algorithm) */
pub fn image_resize_nn(image: *mut Image, new_width: c_int, new_height: c_int) {
    unsafe { rl::ImageResizeNN(image, new_width, new_height) };
}

/** Resize canvas and fill with color */
pub fn image_resize_canvas(
    image: *mut Image,
    new_width: c_int,
    new_height: c_int,
    offset_x: c_int,
    offset_y: c_int,
    fill: Color,
) {
    unsafe { rl::ImageResizeCanvas(image, new_width, new_height, offset_x, offset_y, fill) };
}

/** Compute all mipmap levels for a provided image */
pub fn image_mipmaps(image: *mut Image) {
    unsafe { rl::ImageMipmaps(image) };
}

/** Dither image data to 16bpp or lower (Floyd-Steinberg dithering) */
pub fn image_dither(image: *mut Image, r_bpp: c_int, g_bpp: c_int, b_bpp: c_int, a_bpp: c_int) {
    unsafe { rl::ImageDither(image, r_bpp, g_bpp, b_bpp, a_bpp) };
}

/** Flip image vertically */
pub fn image_flip_vertical(image: *mut Image) {
    unsafe { rl::ImageFlipVertical(image) };
}

/** Flip image horizontally */
pub fn image_flip_horizontal(image: *mut Image) {
    unsafe { rl::ImageFlipHorizontal(image) };
}

/** Rotate image by input angle in degrees (-359 to 359) */
pub fn image_rotate(image: *mut Image, degrees: c_int) {
    unsafe { rl::ImageRotate(image, degrees) };
}

/** Rotate image clockwise 90deg */
pub fn image_rotate_cw(image: *mut Image) {
    unsafe { rl::ImageRotateCW(image) };
}

/** Rotate image counter-clockwise 90deg */
pub fn image_rotate_ccw(image: *mut Image) {
    unsafe { rl::ImageRotateCCW(image) };
}

/** Modify image color: tint */
pub fn image_color_tint(image: *mut Image, color: Color) {
    unsafe { rl::ImageColorTint(image, color) };
}

/** Modify image color: invert */
pub fn image_color_invert(image: *mut Image) {
    unsafe { rl::ImageColorInvert(image) };
}

/** Modify image color: grayscale */
pub fn image_color_grayscale(image: *mut Image) {
    unsafe { rl::ImageColorGrayscale(image) };
}

/** Modify image color: contrast (-100 to 100) */
pub fn image_color_contrast(image: *mut Image, contrast: f32) {
    unsafe { rl::ImageColorContrast(image, contrast) };
}

/** Modify image color: brightness (-255 to 255) */
pub fn image_color_brightness(image: *mut Image, brightness: c_int) {
    unsafe { rl::ImageColorBrightness(image, brightness) };
}

/** Modify image color: replace color */
pub fn image_color_replace(image: *mut Image, color: Color, replace: Color) {
    unsafe { rl::ImageColorReplace(image, color, replace) };
}

/** Load color data from image as a Color array (RGBA - 32bit) */
pub fn load_image_colors(image: Image) -> *mut Color {
    return unsafe { rl::LoadImageColors(image) };
}

/** Load colors palette from image as a Color array (RGBA - 32bit) */
pub fn load_image_palette(
    image: Image,
    max_palette_size: c_int,
    color_count: *mut c_int,
) -> *mut Color {
    return unsafe { rl::LoadImagePalette(image, max_palette_size, color_count) };
}

/** Unload color data loaded with LoadImageColors() */
pub fn unload_image_colors(colors: *mut Color) {
    unsafe { rl::UnloadImageColors(colors) };
}

/** Unload colors palette loaded with LoadImagePalette() */
pub fn unload_image_palette(colors: *mut Color) {
    unsafe { rl::UnloadImagePalette(colors) };
}

/** Get image alpha border rectangle */
pub fn get_image_alpha_border(image: Image, threshold: f32) -> Rectangle {
    return unsafe { rl::GetImageAlphaBorder(image, threshold) };
}

/** Get image pixel color at (x, y) position */
pub fn get_image_color(image: Image, x: c_int, y: c_int) -> Color {
    return unsafe { rl::GetImageColor(image, x, y) };
}

/** Clear image background with given color */
pub fn image_clear_background(dst: *mut Image, color: Color) {
    unsafe { rl::ImageClearBackground(dst, color) };
}

/** Draw pixel within an image */
pub fn image_draw_pixel(dst: *mut Image, pos_x: c_int, pos_y: c_int, color: Color) {
    unsafe { rl::ImageDrawPixel(dst, pos_x, pos_y, color) };
}

/** Draw pixel within an image (Vector version) */
pub fn image_draw_pixel_v(dst: *mut Image, position: Vector2, color: Color) {
    unsafe { rl::ImageDrawPixelV(dst, position, color) };
}

/** Draw line within an image */
pub fn image_draw_line(
    dst: *mut Image,
    start_pos_x: c_int,
    start_pos_y: c_int,
    end_pos_x: c_int,
    end_pos_y: c_int,
    color: Color,
) {
    unsafe { rl::ImageDrawLine(dst, start_pos_x, start_pos_y, end_pos_x, end_pos_y, color) };
}

/** Draw line within an image (Vector version) */
pub fn image_draw_line_v(dst: *mut Image, start: Vector2, end: Vector2, color: Color) {
    unsafe { rl::ImageDrawLineV(dst, start, end, color) };
}

/** Draw a filled circle within an image */
pub fn image_draw_circle(
    dst: *mut Image,
    center_x: c_int,
    center_y: c_int,
    radius: c_int,
    color: Color,
) {
    unsafe { rl::ImageDrawCircle(dst, center_x, center_y, radius, color) };
}

/** Draw a filled circle within an image (Vector version) */
pub fn image_draw_circle_v(dst: *mut Image, center: Vector2, radius: c_int, color: Color) {
    unsafe { rl::ImageDrawCircleV(dst, center, radius, color) };
}

/** Draw circle outline within an image */
pub fn image_draw_circle_lines(
    dst: *mut Image,
    center_x: c_int,
    center_y: c_int,
    radius: c_int,
    color: Color,
) {
    unsafe { rl::ImageDrawCircleLines(dst, center_x, center_y, radius, color) };
}

/** Draw circle outline within an image (Vector version) */
pub fn image_draw_circle_lines_v(dst: *mut Image, center: Vector2, radius: c_int, color: Color) {
    unsafe { rl::ImageDrawCircleLinesV(dst, center, radius, color) };
}

/** Draw rectangle within an image */
pub fn image_draw_rectangle(
    dst: *mut Image,
    pos_x: c_int,
    pos_y: c_int,
    width: c_int,
    height: c_int,
    color: Color,
) {
    unsafe { rl::ImageDrawRectangle(dst, pos_x, pos_y, width, height, color) };
}

/** Draw rectangle within an image (Vector version) */
pub fn image_draw_rectangle_v(dst: *mut Image, position: Vector2, size: Vector2, color: Color) {
    unsafe { rl::ImageDrawRectangleV(dst, position, size, color) };
}

/** Draw rectangle within an image */
pub fn image_draw_rectangle_rec(dst: *mut Image, rec: Rectangle, color: Color) {
    unsafe { rl::ImageDrawRectangleRec(dst, rec, color) };
}

/** Draw rectangle lines within an image */
pub fn image_draw_rectangle_lines(dst: *mut Image, rec: Rectangle, thick: c_int, color: Color) {
    unsafe { rl::ImageDrawRectangleLines(dst, rec, thick, color) };
}

/** Draw a source image within a destination image (tint applied to source) */
pub fn image_draw(
    dst: *mut Image,
    src: Image,
    src_rec: Rectangle,
    dst_rec: Rectangle,
    tint: Color,
) {
    unsafe { rl::ImageDraw(dst, src, src_rec, dst_rec, tint) };
}

/** Draw text (using default font) within an image (destination) */
pub fn image_draw_text(
    dst: *mut Image,
    text: &str,
    pos_x: c_int,
    pos_y: c_int,
    font_size: c_int,
    color: Color,
) {
    unsafe { rl::ImageDrawText(dst, str_to_c_char(text), pos_x, pos_y, font_size, color) };
}

/** Draw text (custom sprite font) within an image (destination) */
pub fn image_draw_text_ex(
    dst: *mut Image,
    font: Font,
    text: &str,
    position: Vector2,
    font_size: f32,
    spacing: f32,
    tint: Color,
) {
    unsafe {
        rl::ImageDrawTextEx(
            dst,
            font,
            str_to_c_char(text),
            position,
            font_size,
            spacing,
            tint,
        )
    };
}

/** Load texture from file into GPU memory (VRAM) */
pub fn load_texture(file_name: &str) -> Texture2D {
    return unsafe { rl::LoadTexture(str_to_c_char(file_name)) };
}

/** Load texture from image data */
pub fn load_texture_from_image(image: Image) -> Texture2D {
    return unsafe { rl::LoadTextureFromImage(image) };
}

/** Load cubemap from image, multiple image cubemap layouts supported */
pub fn load_texture_cubemap(image: Image, layout: c_int) -> TextureCubemap {
    return unsafe { rl::LoadTextureCubemap(image, layout) };
}

/** Load texture for rendering (framebuffer) */
pub fn load_render_texture(width: c_int, height: c_int) -> RenderTexture2D {
    return unsafe { rl::LoadRenderTexture(width, height) };
}

/** Check if a texture is ready */
pub fn is_texture_ready(texture: Texture2D) -> bool {
    return unsafe { rl::IsTextureReady(texture) };
}

/** Unload texture from GPU memory (VRAM) */
pub fn unload_texture(texture: Texture2D) {
    unsafe { rl::UnloadTexture(texture) };
}

/** Check if a render texture is ready */
pub fn is_render_texture_ready(target: RenderTexture2D) -> bool {
    return unsafe { rl::IsRenderTextureReady(target) };
}

/** Unload render texture from GPU memory (VRAM) */
pub fn unload_render_texture(target: RenderTexture2D) {
    unsafe { rl::UnloadRenderTexture(target) };
}

/** Update GPU texture with new data */
pub fn update_texture(texture: Texture2D, pixels: *const c_void) {
    unsafe { rl::UpdateTexture(texture, pixels) };
}

/** Update GPU texture rectangle with new data */
pub fn update_texture_rec(texture: Texture2D, rec: Rectangle, pixels: *const c_void) {
    unsafe { rl::UpdateTextureRec(texture, rec, pixels) };
}

/** Generate GPU mipmaps for a texture */
pub fn gen_texture_mipmaps(texture: *mut Texture2D) {
    unsafe { rl::GenTextureMipmaps(texture) };
}

/** Set texture scaling filter mode */
pub fn set_texture_filter(texture: Texture2D, filter: c_int) {
    unsafe { rl::SetTextureFilter(texture, filter) };
}

/** Set texture wrapping mode */
pub fn set_texture_wrap(texture: Texture2D, wrap: c_int) {
    unsafe { rl::SetTextureWrap(texture, wrap) };
}

/** Draw a Texture2D */
pub fn draw_texture(texture: Texture2D, pos_x: c_int, pos_y: c_int, tint: Color) {
    unsafe { rl::DrawTexture(texture, pos_x, pos_y, tint) };
}

/** Draw a Texture2D with position defined as Vector2 */
pub fn draw_texture_v(texture: Texture2D, position: Vector2, tint: Color) {
    unsafe { rl::DrawTextureV(texture, position, tint) };
}

/** Draw a Texture2D with extended parameters */
pub fn draw_texture_ex(
    texture: Texture2D,
    position: Vector2,
    rotation: f32,
    scale: f32,
    tint: Color,
) {
    unsafe { rl::DrawTextureEx(texture, position, rotation, scale, tint) };
}

/** Draw a part of a texture defined by a rectangle */
pub fn draw_texture_rec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) {
    unsafe { rl::DrawTextureRec(texture, source, position, tint) };
}

/** Draw a part of a texture defined by a rectangle with 'pro' parameters */
pub fn draw_texture_pro(
    texture: Texture2D,
    source: Rectangle,
    dest: Rectangle,
    origin: Vector2,
    rotation: f32,
    tint: Color,
) {
    unsafe { rl::DrawTexturePro(texture, source, dest, origin, rotation, tint) };
}

/** Draws a texture (or part of it) that stretches or shrinks nicely */
pub fn draw_texture_n_patch(
    texture: Texture2D,
    n_patch_info: NPatchInfo,
    dest: Rectangle,
    origin: Vector2,
    rotation: f32,
    tint: Color,
) {
    unsafe { rl::DrawTextureNPatch(texture, n_patch_info, dest, origin, rotation, tint) };
}

/** Get color with alpha applied, alpha goes from 0.0f to 1.0f */
pub fn fade(color: Color, alpha: f32) -> Color {
    return unsafe { rl::Fade(color, alpha) };
}

/** Get hexadecimal value for a Color */
pub fn color_to_int(color: Color) -> c_int {
    return unsafe { rl::ColorToInt(color) };
}

/** Get Color normalized as float [0..1] */
pub fn color_normalize(color: Color) -> Vector4 {
    return unsafe { rl::ColorNormalize(color) };
}

/** Get Color from normalized values [0..1] */
pub fn color_from_normalized(normalized: Vector4) -> Color {
    return unsafe { rl::ColorFromNormalized(normalized) };
}

/** Get HSV values for a Color, hue [0..360], saturation/value [0..1] */
pub fn color_to_hsv(color: Color) -> Vector3 {
    return unsafe { rl::ColorToHSV(color) };
}

/** Get a Color from HSV values, hue [0..360], saturation/value [0..1] */
pub fn color_from_hsv(hue: f32, saturation: f32, value: f32) -> Color {
    return unsafe { rl::ColorFromHSV(hue, saturation, value) };
}

/** Get color multiplied with another color */
pub fn color_tint(color: Color, tint: Color) -> Color {
    return unsafe { rl::ColorTint(color, tint) };
}

/** Get color with brightness correction, brightness factor goes from -1.0f to 1.0f */
pub fn color_brightness(color: Color, factor: f32) -> Color {
    return unsafe { rl::ColorBrightness(color, factor) };
}

/** Get color with contrast correction, contrast values between -1.0f and 1.0f */
pub fn color_contrast(color: Color, contrast: f32) -> Color {
    return unsafe { rl::ColorContrast(color, contrast) };
}

/** Get color with alpha applied, alpha goes from 0.0f to 1.0f */
pub fn color_alpha(color: Color, alpha: f32) -> Color {
    return unsafe { rl::ColorAlpha(color, alpha) };
}

/** Get src alpha-blended into dst color with tint */
pub fn color_alpha_blend(dst: Color, src: Color, tint: Color) -> Color {
    return unsafe { rl::ColorAlphaBlend(dst, src, tint) };
}

/** Get Color structure from hexadecimal value */
pub fn get_color(hex_value: c_uint) -> Color {
    return unsafe { rl::GetColor(hex_value) };
}

/** Get Color from a source pixel pointer of certain format */
pub fn get_pixel_color(src_ptr: *mut c_void, format: c_int) -> Color {
    return unsafe { rl::GetPixelColor(src_ptr, format) };
}

/** Set color formatted into destination pixel pointer */
pub fn set_pixel_color(dst_ptr: *mut c_void, color: Color, format: c_int) {
    unsafe { rl::SetPixelColor(dst_ptr, color, format) };
}

/** Get pixel data size in bytes for certain format */
pub fn get_pixel_data_size(width: c_int, height: c_int, format: c_int) -> c_int {
    return unsafe { rl::GetPixelDataSize(width, height, format) };
}

/** Get the default Font */
pub fn get_font_default() -> Font {
    return unsafe { rl::GetFontDefault() };
}

/** Load font from file into GPU memory (VRAM) */
pub fn load_font(file_name: &str) -> Font {
    return unsafe { rl::LoadFont(str_to_c_char(file_name)) };
}

/** Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character setFont */
pub fn load_font_ex(
    file_name: &str,
    font_size: c_int,
    codepoints: *mut c_int,
    codepoint_count: c_int,
) -> Font {
    return unsafe {
        rl::LoadFontEx(
            str_to_c_char(file_name),
            font_size,
            codepoints,
            codepoint_count,
        )
    };
}

/** Load font from Image (XNA style) */
pub fn load_font_from_image(image: Image, key: Color, first_char: c_int) -> Font {
    return unsafe { rl::LoadFontFromImage(image, key, first_char) };
}

/** Load font from memory buffer, fileType refers to extension: i.e. '.ttf' */
pub fn load_font_from_memory(
    file_type: &str,
    file_data: *const c_uchar,
    data_size: c_int,
    font_size: c_int,
    codepoints: *mut c_int,
    codepoint_count: c_int,
) -> Font {
    return unsafe {
        rl::LoadFontFromMemory(
            str_to_c_char(file_type),
            file_data,
            data_size,
            font_size,
            codepoints,
            codepoint_count,
        )
    };
}

/** Check if a font is ready */
pub fn is_font_ready(font: Font) -> bool {
    return unsafe { rl::IsFontReady(font) };
}

/** Load font data for further use */
pub fn load_font_data(
    file_data: *const c_uchar,
    data_size: c_int,
    font_size: c_int,
    codepoints: *mut c_int,
    codepoint_count: c_int,
    type_: c_int,
) -> *mut GlyphInfo {
    return unsafe {
        rl::LoadFontData(
            file_data,
            data_size,
            font_size,
            codepoints,
            codepoint_count,
            type_,
        )
    };
}

/** Generate image font atlas using chars info */
pub fn gen_image_font_atlas(
    glyphs: *const GlyphInfo,
    glyph_recs: *mut *mut Rectangle,
    glyph_count: c_int,
    font_size: c_int,
    padding: c_int,
    pack_method: c_int,
) -> Image {
    return unsafe {
        rl::GenImageFontAtlas(
            glyphs,
            glyph_recs,
            glyph_count,
            font_size,
            padding,
            pack_method,
        )
    };
}

/** Unload font chars info data (RAM) */
pub fn unload_font_data(glyphs: *mut GlyphInfo, glyph_count: c_int) {
    unsafe { rl::UnloadFontData(glyphs, glyph_count) };
}

/** Unload font from GPU memory (VRAM) */
pub fn unload_font(font: Font) {
    unsafe { rl::UnloadFont(font) };
}

/** Export font as code file, returns true on success */
pub fn export_font_as_code(font: Font, file_name: &str) -> bool {
    return unsafe { rl::ExportFontAsCode(font, str_to_c_char(file_name)) };
}

/** Draw current FPS */
pub fn draw_fps(pos_x: c_int, pos_y: c_int) {
    unsafe { rl::DrawFPS(pos_x, pos_y) };
}

/** Draw text (using default font) */
pub fn draw_text(text: &str, pos_x: c_int, pos_y: c_int, font_size: c_int, color: Color) {
    unsafe { rl::DrawText(str_to_c_char(text), pos_x, pos_y, font_size, color) };
}

/** Draw text using font and additional parameters */
pub fn draw_text_ex(
    font: Font,
    text: &str,
    position: Vector2,
    font_size: f32,
    spacing: f32,
    tint: Color,
) {
    unsafe {
        rl::DrawTextEx(
            font,
            str_to_c_char(text),
            position,
            font_size,
            spacing,
            tint,
        )
    };
}

/** Draw text using Font and pro parameters (rotation) */
pub fn draw_text_pro(
    font: Font,
    text: &str,
    position: Vector2,
    origin: Vector2,
    rotation: f32,
    font_size: f32,
    spacing: f32,
    tint: Color,
) {
    unsafe {
        rl::DrawTextPro(
            font,
            str_to_c_char(text),
            position,
            origin,
            rotation,
            font_size,
            spacing,
            tint,
        )
    };
}

/** Draw one character (codepoint) */
pub fn draw_text_codepoint(
    font: Font,
    codepoint: c_int,
    position: Vector2,
    font_size: f32,
    tint: Color,
) {
    unsafe { rl::DrawTextCodepoint(font, codepoint, position, font_size, tint) };
}

/** Draw multiple character (codepoint) */
pub fn draw_text_codepoints(
    font: Font,
    codepoints: *const c_int,
    codepoint_count: c_int,
    position: Vector2,
    font_size: f32,
    spacing: f32,
    tint: Color,
) {
    unsafe {
        rl::DrawTextCodepoints(
            font,
            codepoints,
            codepoint_count,
            position,
            font_size,
            spacing,
            tint,
        )
    };
}

/** Set vertical line spacing when drawing with line-breaks */
pub fn set_text_line_spacing(spacing: c_int) {
    unsafe { rl::SetTextLineSpacing(spacing) };
}

/** Measure string width for default font */
pub fn measure_text(text: &str, font_size: c_int) -> c_int {
    return unsafe { rl::MeasureText(str_to_c_char(text), font_size) };
}

/** Measure string size for Font */
pub fn measure_text_ex(font: Font, text: &str, font_size: f32, spacing: f32) -> Vector2 {
    return unsafe { rl::MeasureTextEx(font, str_to_c_char(text), font_size, spacing) };
}

/** Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found */
pub fn get_glyph_index(font: Font, codepoint: c_int) -> c_int {
    return unsafe { rl::GetGlyphIndex(font, codepoint) };
}

/** Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found */
pub fn get_glyph_info(font: Font, codepoint: c_int) -> GlyphInfo {
    return unsafe { rl::GetGlyphInfo(font, codepoint) };
}

/** Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found */
pub fn get_glyph_atlas_rec(font: Font, codepoint: c_int) -> Rectangle {
    return unsafe { rl::GetGlyphAtlasRec(font, codepoint) };
}

/** Load UTF-8 text encoded from codepoints array */
pub fn load_utf_8(codepoints: *const c_int, length: c_int) -> *mut c_char {
    return unsafe { rl::LoadUTF8(codepoints, length) };
}

/** Unload UTF-8 text encoded from codepoints array */
pub fn unload_utf_8(text: *mut c_char) {
    unsafe { rl::UnloadUTF8(text) };
}

/** Load all codepoints from a UTF-8 text string, codepoints count returned by parameter */
pub fn load_codepoints(text: &str, count: *mut c_int) -> *mut c_int {
    return unsafe { rl::LoadCodepoints(str_to_c_char(text), count) };
}

/** Unload codepoints data from memory */
pub fn unload_codepoints(codepoints: *mut c_int) {
    unsafe { rl::UnloadCodepoints(codepoints) };
}

/** Get total number of codepoints in a UTF-8 encoded string */
pub fn get_codepoint_count(text: &str) -> c_int {
    return unsafe { rl::GetCodepointCount(str_to_c_char(text)) };
}

/** Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure */
pub fn get_codepoint(text: &str, codepoint_size: *mut c_int) -> c_int {
    return unsafe { rl::GetCodepoint(str_to_c_char(text), codepoint_size) };
}

/** Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure */
pub fn get_codepoint_next(text: &str, codepoint_size: *mut c_int) -> c_int {
    return unsafe { rl::GetCodepointNext(str_to_c_char(text), codepoint_size) };
}

/** Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure */
pub fn get_codepoint_previous(text: &str, codepoint_size: *mut c_int) -> c_int {
    return unsafe { rl::GetCodepointPrevious(str_to_c_char(text), codepoint_size) };
}

/** Encode one codepoint into UTF-8 byte array (array length returned as parameter) */
pub fn codepoint_to_utf_8(codepoint: c_int, utf_8_size: *mut c_int) -> String {
    return unsafe { CStr::from_ptr(rl::CodepointToUTF8(codepoint, utf_8_size)) }
        .to_string_lossy()
        .into();
}

/** Copy one string to another, returns bytes copied */
pub fn text_copy(dst: *mut c_char, src: &str) -> c_int {
    return unsafe { rl::TextCopy(dst, str_to_c_char(src)) };
}

/** Check if two text string are equal */
pub fn text_is_equal(text_1: &str, text_2: &str) -> bool {
    return unsafe { rl::TextIsEqual(str_to_c_char(text_1), str_to_c_char(text_2)) };
}

/** Get text length, checks for '\0' ending */
pub fn text_length(text: &str) -> c_uint {
    return unsafe { rl::TextLength(str_to_c_char(text)) };
}

/** Text formatting with variables (sprintf() style) */
pub fn text_format(text: &str) -> String {
    return unsafe { CStr::from_ptr(rl::TextFormat(str_to_c_char(text))) }
        .to_string_lossy()
        .into();
}

/** Get a piece of a text string */
pub fn text_subtext(text: &str, position: c_int, length: c_int) -> String {
    return unsafe { CStr::from_ptr(rl::TextSubtext(str_to_c_char(text), position, length)) }
        .to_string_lossy()
        .into();
}

/** Replace text string (WARNING: memory must be freed!) */
pub fn text_replace(text: *mut c_char, replace: &str, by: &str) -> *mut c_char {
    return unsafe { rl::TextReplace(text, str_to_c_char(replace), str_to_c_char(by)) };
}

/** Insert text in a position (WARNING: memory must be freed!) */
pub fn text_insert(text: &str, insert: &str, position: c_int) -> *mut c_char {
    return unsafe { rl::TextInsert(str_to_c_char(text), str_to_c_char(insert), position) };
}

/** Join text strings with delimiter */
pub fn text_join(text_list: *mut *const c_char, count: c_int, delimiter: &str) -> String {
    return unsafe { CStr::from_ptr(rl::TextJoin(text_list, count, str_to_c_char(delimiter))) }
        .to_string_lossy()
        .into();
}

/** Split text into multiple strings */
pub fn text_split(text: &str, delimiter: c_char, count: *mut c_int) -> *mut *const c_char {
    return unsafe { rl::TextSplit(str_to_c_char(text), delimiter, count) };
}

/** Append text at specific position and move cursor! */
pub fn text_append(text: *mut c_char, append: &str, position: *mut c_int) {
    unsafe { rl::TextAppend(text, str_to_c_char(append), position) };
}

/** Find first text occurrence within a string */
pub fn text_find_index(text: &str, find: &str) -> c_int {
    return unsafe { rl::TextFindIndex(str_to_c_char(text), str_to_c_char(find)) };
}

/** Get upper case version of provided string */
pub fn text_to_upper(text: &str) -> String {
    return unsafe { CStr::from_ptr(rl::TextToUpper(str_to_c_char(text))) }
        .to_string_lossy()
        .into();
}

/** Get lower case version of provided string */
pub fn text_to_lower(text: &str) -> String {
    return unsafe { CStr::from_ptr(rl::TextToLower(str_to_c_char(text))) }
        .to_string_lossy()
        .into();
}

/** Get Pascal case notation version of provided string */
pub fn text_to_pascal(text: &str) -> String {
    return unsafe { CStr::from_ptr(rl::TextToPascal(str_to_c_char(text))) }
        .to_string_lossy()
        .into();
}

/** Get integer value from text (negative values not supported) */
pub fn text_to_integer(text: &str) -> c_int {
    return unsafe { rl::TextToInteger(str_to_c_char(text)) };
}

/** Draw a line in 3D world space */
pub fn draw_line_3_d(start_pos: Vector3, end_pos: Vector3, color: Color) {
    unsafe { rl::DrawLine3D(start_pos, end_pos, color) };
}

/** Draw a point in 3D space, actually a small line */
pub fn draw_point_3_d(position: Vector3, color: Color) {
    unsafe { rl::DrawPoint3D(position, color) };
}

/** Draw a circle in 3D world space */
pub fn draw_circle_3_d(
    center: Vector3,
    radius: f32,
    rotation_axis: Vector3,
    rotation_angle: f32,
    color: Color,
) {
    unsafe { rl::DrawCircle3D(center, radius, rotation_axis, rotation_angle, color) };
}

/** Draw a color-filled triangle (vertex in counter-clockwise order!) */
pub fn draw_triangle_3_d(v_1: Vector3, v_2: Vector3, v_3: Vector3, color: Color) {
    unsafe { rl::DrawTriangle3D(v_1, v_2, v_3, color) };
}

/** Draw a triangle strip defined by points */
pub fn draw_triangle_strip_3_d(points: *mut Vector3, point_count: c_int, color: Color) {
    unsafe { rl::DrawTriangleStrip3D(points, point_count, color) };
}

/** Draw cube */
pub fn draw_cube(position: Vector3, width: f32, height: f32, length: f32, color: Color) {
    unsafe { rl::DrawCube(position, width, height, length, color) };
}

/** Draw cube (Vector version) */
pub fn draw_cube_v(position: Vector3, size: Vector3, color: Color) {
    unsafe { rl::DrawCubeV(position, size, color) };
}

/** Draw cube wires */
pub fn draw_cube_wires(position: Vector3, width: f32, height: f32, length: f32, color: Color) {
    unsafe { rl::DrawCubeWires(position, width, height, length, color) };
}

/** Draw cube wires (Vector version) */
pub fn draw_cube_wires_v(position: Vector3, size: Vector3, color: Color) {
    unsafe { rl::DrawCubeWiresV(position, size, color) };
}

/** Draw sphere */
pub fn draw_sphere(center_pos: Vector3, radius: f32, color: Color) {
    unsafe { rl::DrawSphere(center_pos, radius, color) };
}

/** Draw sphere with extended parameters */
pub fn draw_sphere_ex(center_pos: Vector3, radius: f32, rings: c_int, slices: c_int, color: Color) {
    unsafe { rl::DrawSphereEx(center_pos, radius, rings, slices, color) };
}

/** Draw sphere wires */
pub fn draw_sphere_wires(
    center_pos: Vector3,
    radius: f32,
    rings: c_int,
    slices: c_int,
    color: Color,
) {
    unsafe { rl::DrawSphereWires(center_pos, radius, rings, slices, color) };
}

/** Draw a cylinder/cone */
pub fn draw_cylinder(
    position: Vector3,
    radius_top: f32,
    radius_bottom: f32,
    height: f32,
    slices: c_int,
    color: Color,
) {
    unsafe { rl::DrawCylinder(position, radius_top, radius_bottom, height, slices, color) };
}

/** Draw a cylinder with base at startPos and top at endPos */
pub fn draw_cylinder_ex(
    start_pos: Vector3,
    end_pos: Vector3,
    start_radius: f32,
    end_radius: f32,
    sides: c_int,
    color: Color,
) {
    unsafe { rl::DrawCylinderEx(start_pos, end_pos, start_radius, end_radius, sides, color) };
}

/** Draw a cylinder/cone wires */
pub fn draw_cylinder_wires(
    position: Vector3,
    radius_top: f32,
    radius_bottom: f32,
    height: f32,
    slices: c_int,
    color: Color,
) {
    unsafe { rl::DrawCylinderWires(position, radius_top, radius_bottom, height, slices, color) };
}

/** Draw a cylinder wires with base at startPos and top at endPos */
pub fn draw_cylinder_wires_ex(
    start_pos: Vector3,
    end_pos: Vector3,
    start_radius: f32,
    end_radius: f32,
    sides: c_int,
    color: Color,
) {
    unsafe { rl::DrawCylinderWiresEx(start_pos, end_pos, start_radius, end_radius, sides, color) };
}

/** Draw a capsule with the center of its sphere caps at startPos and endPos */
pub fn draw_capsule(
    start_pos: Vector3,
    end_pos: Vector3,
    radius: f32,
    slices: c_int,
    rings: c_int,
    color: Color,
) {
    unsafe { rl::DrawCapsule(start_pos, end_pos, radius, slices, rings, color) };
}

/** Draw capsule wireframe with the center of its sphere caps at startPos and endPos */
pub fn draw_capsule_wires(
    start_pos: Vector3,
    end_pos: Vector3,
    radius: f32,
    slices: c_int,
    rings: c_int,
    color: Color,
) {
    unsafe { rl::DrawCapsuleWires(start_pos, end_pos, radius, slices, rings, color) };
}

/** Draw a plane XZ */
pub fn draw_plane(center_pos: Vector3, size: Vector2, color: Color) {
    unsafe { rl::DrawPlane(center_pos, size, color) };
}

/** Draw a ray line */
pub fn draw_ray(ray: Ray, color: Color) {
    unsafe { rl::DrawRay(ray, color) };
}

/** Draw a grid (centered at (0, 0, 0)) */
pub fn draw_grid(slices: c_int, spacing: f32) {
    unsafe { rl::DrawGrid(slices, spacing) };
}

/** Load model from files (meshes and materials) */
pub fn load_model(file_name: &str) -> Model {
    return unsafe { rl::LoadModel(str_to_c_char(file_name)) };
}

/** Load model from generated mesh (default material) */
pub fn load_model_from_mesh(mesh: Mesh) -> Model {
    return unsafe { rl::LoadModelFromMesh(mesh) };
}

/** Check if a model is ready */
pub fn is_model_ready(model: Model) -> bool {
    return unsafe { rl::IsModelReady(model) };
}

/** Unload model (including meshes) from memory (RAM and/or VRAM) */
pub fn unload_model(model: Model) {
    unsafe { rl::UnloadModel(model) };
}

/** Compute model bounding box limits (considers all meshes) */
pub fn get_model_bounding_box(model: Model) -> BoundingBox {
    return unsafe { rl::GetModelBoundingBox(model) };
}

/** Draw a model (with texture if set) */
pub fn draw_model(model: Model, position: Vector3, scale: f32, tint: Color) {
    unsafe { rl::DrawModel(model, position, scale, tint) };
}

/** Draw a model with extended parameters */
pub fn draw_model_ex(
    model: Model,
    position: Vector3,
    rotation_axis: Vector3,
    rotation_angle: f32,
    scale: Vector3,
    tint: Color,
) {
    unsafe { rl::DrawModelEx(model, position, rotation_axis, rotation_angle, scale, tint) };
}

/** Draw a model wires (with texture if set) */
pub fn draw_model_wires(model: Model, position: Vector3, scale: f32, tint: Color) {
    unsafe { rl::DrawModelWires(model, position, scale, tint) };
}

/** Draw a model wires (with texture if set) with extended parameters */
pub fn draw_model_wires_ex(
    model: Model,
    position: Vector3,
    rotation_axis: Vector3,
    rotation_angle: f32,
    scale: Vector3,
    tint: Color,
) {
    unsafe { rl::DrawModelWiresEx(model, position, rotation_axis, rotation_angle, scale, tint) };
}

/** Draw bounding box (wires) */
pub fn draw_bounding_box(box_: BoundingBox, color: Color) {
    unsafe { rl::DrawBoundingBox(box_, color) };
}

/** Draw a billboard texture */
pub fn draw_billboard(
    camera: Camera,
    texture: Texture2D,
    position: Vector3,
    size: f32,
    tint: Color,
) {
    unsafe { rl::DrawBillboard(camera, texture, position, size, tint) };
}

/** Draw a billboard texture defined by source */
pub fn draw_billboard_rec(
    camera: Camera,
    texture: Texture2D,
    source: Rectangle,
    position: Vector3,
    size: Vector2,
    tint: Color,
) {
    unsafe { rl::DrawBillboardRec(camera, texture, source, position, size, tint) };
}

/** Draw a billboard texture defined by source and rotation */
pub fn draw_billboard_pro(
    camera: Camera,
    texture: Texture2D,
    source: Rectangle,
    position: Vector3,
    up: Vector3,
    size: Vector2,
    origin: Vector2,
    rotation: f32,
    tint: Color,
) {
    unsafe {
        rl::DrawBillboardPro(
            camera, texture, source, position, up, size, origin, rotation, tint,
        )
    };
}

/** Upload mesh vertex data in GPU and provide VAO/VBO ids */
pub fn upload_mesh(mesh: *mut Mesh, dynamic: bool) {
    unsafe { rl::UploadMesh(mesh, dynamic) };
}

/** Update mesh vertex data in GPU for a specific buffer index */
pub fn update_mesh_buffer(
    mesh: Mesh,
    index: c_int,
    data: *const c_void,
    data_size: c_int,
    offset: c_int,
) {
    unsafe { rl::UpdateMeshBuffer(mesh, index, data, data_size, offset) };
}

/** Unload mesh data from CPU and GPU */
pub fn unload_mesh(mesh: Mesh) {
    unsafe { rl::UnloadMesh(mesh) };
}

/** Draw a 3d mesh with material and transform */
pub fn draw_mesh(mesh: Mesh, material: Material, transform: Matrix) {
    unsafe { rl::DrawMesh(mesh, material, transform) };
}

/** Draw multiple mesh instances with material and different transforms */
pub fn draw_mesh_instanced(
    mesh: Mesh,
    material: Material,
    transforms: *const Matrix,
    instances: c_int,
) {
    unsafe { rl::DrawMeshInstanced(mesh, material, transforms, instances) };
}

/** Export mesh data to file, returns true on success */
pub fn export_mesh(mesh: Mesh, file_name: &str) -> bool {
    return unsafe { rl::ExportMesh(mesh, str_to_c_char(file_name)) };
}

/** Compute mesh bounding box limits */
pub fn get_mesh_bounding_box(mesh: Mesh) -> BoundingBox {
    return unsafe { rl::GetMeshBoundingBox(mesh) };
}

/** Compute mesh tangents */
pub fn gen_mesh_tangents(mesh: *mut Mesh) {
    unsafe { rl::GenMeshTangents(mesh) };
}

/** Generate polygonal mesh */
pub fn gen_mesh_poly(sides: c_int, radius: f32) -> Mesh {
    return unsafe { rl::GenMeshPoly(sides, radius) };
}

/** Generate plane mesh (with subdivisions) */
pub fn gen_mesh_plane(width: f32, length: f32, res_x: c_int, res_z: c_int) -> Mesh {
    return unsafe { rl::GenMeshPlane(width, length, res_x, res_z) };
}

/** Generate cuboid mesh */
pub fn gen_mesh_cube(width: f32, height: f32, length: f32) -> Mesh {
    return unsafe { rl::GenMeshCube(width, height, length) };
}

/** Generate sphere mesh (standard sphere) */
pub fn gen_mesh_sphere(radius: f32, rings: c_int, slices: c_int) -> Mesh {
    return unsafe { rl::GenMeshSphere(radius, rings, slices) };
}

/** Generate half-sphere mesh (no bottom cap) */
pub fn gen_mesh_hemi_sphere(radius: f32, rings: c_int, slices: c_int) -> Mesh {
    return unsafe { rl::GenMeshHemiSphere(radius, rings, slices) };
}

/** Generate cylinder mesh */
pub fn gen_mesh_cylinder(radius: f32, height: f32, slices: c_int) -> Mesh {
    return unsafe { rl::GenMeshCylinder(radius, height, slices) };
}

/** Generate cone/pyramid mesh */
pub fn gen_mesh_cone(radius: f32, height: f32, slices: c_int) -> Mesh {
    return unsafe { rl::GenMeshCone(radius, height, slices) };
}

/** Generate torus mesh */
pub fn gen_mesh_torus(radius: f32, size: f32, rad_seg: c_int, sides: c_int) -> Mesh {
    return unsafe { rl::GenMeshTorus(radius, size, rad_seg, sides) };
}

/** Generate trefoil knot mesh */
pub fn gen_mesh_knot(radius: f32, size: f32, rad_seg: c_int, sides: c_int) -> Mesh {
    return unsafe { rl::GenMeshKnot(radius, size, rad_seg, sides) };
}

/** Generate heightmap mesh from image data */
pub fn gen_mesh_heightmap(heightmap: Image, size: Vector3) -> Mesh {
    return unsafe { rl::GenMeshHeightmap(heightmap, size) };
}

/** Generate cubes-based map mesh from image data */
pub fn gen_mesh_cubicmap(cubicmap: Image, cube_size: Vector3) -> Mesh {
    return unsafe { rl::GenMeshCubicmap(cubicmap, cube_size) };
}

/** Load materials from model file */
pub fn load_materials(file_name: &str, material_count: *mut c_int) -> *mut Material {
    return unsafe { rl::LoadMaterials(str_to_c_char(file_name), material_count) };
}

/** Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps) */
pub fn load_material_default() -> Material {
    return unsafe { rl::LoadMaterialDefault() };
}

/** Check if a material is ready */
pub fn is_material_ready(material: Material) -> bool {
    return unsafe { rl::IsMaterialReady(material) };
}

/** Unload material from GPU memory (VRAM) */
pub fn unload_material(material: Material) {
    unsafe { rl::UnloadMaterial(material) };
}

/** Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...) */
pub fn set_material_texture(material: *mut Material, map_type: c_int, texture: Texture2D) {
    unsafe { rl::SetMaterialTexture(material, map_type, texture) };
}

/** Set material for a mesh */
pub fn set_model_mesh_material(model: *mut Model, mesh_id: c_int, material_id: c_int) {
    unsafe { rl::SetModelMeshMaterial(model, mesh_id, material_id) };
}

/** Load model animations from file */
pub fn load_model_animations(file_name: &str, anim_count: *mut c_int) -> *mut ModelAnimation {
    return unsafe { rl::LoadModelAnimations(str_to_c_char(file_name), anim_count) };
}

/** Update model animation pose */
pub fn update_model_animation(model: Model, anim: ModelAnimation, frame: c_int) {
    unsafe { rl::UpdateModelAnimation(model, anim, frame) };
}

/** Unload animation data */
pub fn unload_model_animation(anim: ModelAnimation) {
    unsafe { rl::UnloadModelAnimation(anim) };
}

/** Unload animation array data */
pub fn unload_model_animations(animations: *mut ModelAnimation, anim_count: c_int) {
    unsafe { rl::UnloadModelAnimations(animations, anim_count) };
}

/** Check model animation skeleton match */
pub fn is_model_animation_valid(model: Model, anim: ModelAnimation) -> bool {
    return unsafe { rl::IsModelAnimationValid(model, anim) };
}

/** Check collision between two spheres */
pub fn check_collision_spheres(
    center_1: Vector3,
    radius_1: f32,
    center_2: Vector3,
    radius_2: f32,
) -> bool {
    return unsafe { rl::CheckCollisionSpheres(center_1, radius_1, center_2, radius_2) };
}

/** Check collision between two bounding boxes */
pub fn check_collision_boxes(box_1: BoundingBox, box_2: BoundingBox) -> bool {
    return unsafe { rl::CheckCollisionBoxes(box_1, box_2) };
}

/** Check collision between box and sphere */
pub fn check_collision_box_sphere(box_: BoundingBox, center: Vector3, radius: f32) -> bool {
    return unsafe { rl::CheckCollisionBoxSphere(box_, center, radius) };
}

/** Get collision info between ray and sphere */
pub fn get_ray_collision_sphere(ray: Ray, center: Vector3, radius: f32) -> RayCollision {
    return unsafe { rl::GetRayCollisionSphere(ray, center, radius) };
}

/** Get collision info between ray and box */
pub fn get_ray_collision_box(ray: Ray, box_: BoundingBox) -> RayCollision {
    return unsafe { rl::GetRayCollisionBox(ray, box_) };
}

/** Get collision info between ray and mesh */
pub fn get_ray_collision_mesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision {
    return unsafe { rl::GetRayCollisionMesh(ray, mesh, transform) };
}

/** Get collision info between ray and triangle */
pub fn get_ray_collision_triangle(
    ray: Ray,
    p_1: Vector3,
    p_2: Vector3,
    p_3: Vector3,
) -> RayCollision {
    return unsafe { rl::GetRayCollisionTriangle(ray, p_1, p_2, p_3) };
}

/** Get collision info between ray and quad */
pub fn get_ray_collision_quad(
    ray: Ray,
    p_1: Vector3,
    p_2: Vector3,
    p_3: Vector3,
    p_4: Vector3,
) -> RayCollision {
    return unsafe { rl::GetRayCollisionQuad(ray, p_1, p_2, p_3, p_4) };
}

/** Initialize audio device and context */
pub fn init_audio_device() {
    unsafe { rl::InitAudioDevice() };
}

/** Close the audio device and context */
pub fn close_audio_device() {
    unsafe { rl::CloseAudioDevice() };
}

/** Check if audio device has been initialized successfully */
pub fn is_audio_device_ready() -> bool {
    return unsafe { rl::IsAudioDeviceReady() };
}

/** Set master volume (listener) */
pub fn set_master_volume(volume: f32) {
    unsafe { rl::SetMasterVolume(volume) };
}

/** Get master volume (listener) */
pub fn get_master_volume() -> f32 {
    return unsafe { rl::GetMasterVolume() };
}

/** Load wave data from file */
pub fn load_wave(file_name: &str) -> Wave {
    return unsafe { rl::LoadWave(str_to_c_char(file_name)) };
}

/** Load wave from memory buffer, fileType refers to extension: i.e. '.wav' */
pub fn load_wave_from_memory(file_type: &str, file_data: *const c_uchar, data_size: c_int) -> Wave {
    return unsafe { rl::LoadWaveFromMemory(str_to_c_char(file_type), file_data, data_size) };
}

/** Checks if wave data is ready */
pub fn is_wave_ready(wave: Wave) -> bool {
    return unsafe { rl::IsWaveReady(wave) };
}

/** Load sound from file */
pub fn load_sound(file_name: &str) -> Sound {
    return unsafe { rl::LoadSound(str_to_c_char(file_name)) };
}

/** Load sound from wave data */
pub fn load_sound_from_wave(wave: Wave) -> Sound {
    return unsafe { rl::LoadSoundFromWave(wave) };
}

/** Create a new sound that shares the same sample data as the source sound, does not own the sound data */
pub fn load_sound_alias(source: Sound) -> Sound {
    return unsafe { rl::LoadSoundAlias(source) };
}

/** Checks if a sound is ready */
pub fn is_sound_ready(sound: Sound) -> bool {
    return unsafe { rl::IsSoundReady(sound) };
}

/** Update sound buffer with new data */
pub fn update_sound(sound: Sound, data: *const c_void, sample_count: c_int) {
    unsafe { rl::UpdateSound(sound, data, sample_count) };
}

/** Unload wave data */
pub fn unload_wave(wave: Wave) {
    unsafe { rl::UnloadWave(wave) };
}

/** Unload sound */
pub fn unload_sound(sound: Sound) {
    unsafe { rl::UnloadSound(sound) };
}

/** Unload a sound alias (does not deallocate sample data) */
pub fn unload_sound_alias(alias: Sound) {
    unsafe { rl::UnloadSoundAlias(alias) };
}

/** Export wave data to file, returns true on success */
pub fn export_wave(wave: Wave, file_name: &str) -> bool {
    return unsafe { rl::ExportWave(wave, str_to_c_char(file_name)) };
}

/** Export wave sample data to code (.h), returns true on success */
pub fn export_wave_as_code(wave: Wave, file_name: &str) -> bool {
    return unsafe { rl::ExportWaveAsCode(wave, str_to_c_char(file_name)) };
}

/** Play a sound */
pub fn play_sound(sound: Sound) {
    unsafe { rl::PlaySound(sound) };
}

/** Stop playing a sound */
pub fn stop_sound(sound: Sound) {
    unsafe { rl::StopSound(sound) };
}

/** Pause a sound */
pub fn pause_sound(sound: Sound) {
    unsafe { rl::PauseSound(sound) };
}

/** Resume a paused sound */
pub fn resume_sound(sound: Sound) {
    unsafe { rl::ResumeSound(sound) };
}

/** Check if a sound is currently playing */
pub fn is_sound_playing(sound: Sound) -> bool {
    return unsafe { rl::IsSoundPlaying(sound) };
}

/** Set volume for a sound (1.0 is max level) */
pub fn set_sound_volume(sound: Sound, volume: f32) {
    unsafe { rl::SetSoundVolume(sound, volume) };
}

/** Set pitch for a sound (1.0 is base level) */
pub fn set_sound_pitch(sound: Sound, pitch: f32) {
    unsafe { rl::SetSoundPitch(sound, pitch) };
}

/** Set pan for a sound (0.5 is center) */
pub fn set_sound_pan(sound: Sound, pan: f32) {
    unsafe { rl::SetSoundPan(sound, pan) };
}

/** Copy a wave to a new wave */
pub fn wave_copy(wave: Wave) -> Wave {
    return unsafe { rl::WaveCopy(wave) };
}

/** Crop a wave to defined samples range */
pub fn wave_crop(wave: *mut Wave, init_sample: c_int, final_sample: c_int) {
    unsafe { rl::WaveCrop(wave, init_sample, final_sample) };
}

/** Convert wave data to desired format */
pub fn wave_format(wave: *mut Wave, sample_rate: c_int, sample_size: c_int, channels: c_int) {
    unsafe { rl::WaveFormat(wave, sample_rate, sample_size, channels) };
}

/** Load samples data from wave as a 32bit float data array */
pub fn load_wave_samples(wave: Wave) -> *mut f32 {
    return unsafe { rl::LoadWaveSamples(wave) };
}

/** Unload samples data loaded with LoadWaveSamples() */
pub fn unload_wave_samples(samples: *mut f32) {
    unsafe { rl::UnloadWaveSamples(samples) };
}

/** Load music stream from file */
pub fn load_music_stream(file_name: &str) -> Music {
    return unsafe { rl::LoadMusicStream(str_to_c_char(file_name)) };
}

/** Load music stream from data */
pub fn load_music_stream_from_memory(
    file_type: &str,
    data: *const c_uchar,
    data_size: c_int,
) -> Music {
    return unsafe { rl::LoadMusicStreamFromMemory(str_to_c_char(file_type), data, data_size) };
}

/** Checks if a music stream is ready */
pub fn is_music_ready(music: Music) -> bool {
    return unsafe { rl::IsMusicReady(music) };
}

/** Unload music stream */
pub fn unload_music_stream(music: Music) {
    unsafe { rl::UnloadMusicStream(music) };
}

/** Start music playing */
pub fn play_music_stream(music: Music) {
    unsafe { rl::PlayMusicStream(music) };
}

/** Check if music is playing */
pub fn is_music_stream_playing(music: Music) -> bool {
    return unsafe { rl::IsMusicStreamPlaying(music) };
}

/** Updates buffers for music streaming */
pub fn update_music_stream(music: Music) {
    unsafe { rl::UpdateMusicStream(music) };
}

/** Stop music playing */
pub fn stop_music_stream(music: Music) {
    unsafe { rl::StopMusicStream(music) };
}

/** Pause music playing */
pub fn pause_music_stream(music: Music) {
    unsafe { rl::PauseMusicStream(music) };
}

/** Resume playing paused music */
pub fn resume_music_stream(music: Music) {
    unsafe { rl::ResumeMusicStream(music) };
}

/** Seek music to a position (in seconds) */
pub fn seek_music_stream(music: Music, position: f32) {
    unsafe { rl::SeekMusicStream(music, position) };
}

/** Set volume for music (1.0 is max level) */
pub fn set_music_volume(music: Music, volume: f32) {
    unsafe { rl::SetMusicVolume(music, volume) };
}

/** Set pitch for a music (1.0 is base level) */
pub fn set_music_pitch(music: Music, pitch: f32) {
    unsafe { rl::SetMusicPitch(music, pitch) };
}

/** Set pan for a music (0.5 is center) */
pub fn set_music_pan(music: Music, pan: f32) {
    unsafe { rl::SetMusicPan(music, pan) };
}

/** Get music time length (in seconds) */
pub fn get_music_time_length(music: Music) -> f32 {
    return unsafe { rl::GetMusicTimeLength(music) };
}

/** Get current music time played (in seconds) */
pub fn get_music_time_played(music: Music) -> f32 {
    return unsafe { rl::GetMusicTimePlayed(music) };
}

/** Load audio stream (to stream raw audio pcm data) */
pub fn load_audio_stream(
    sample_rate: c_uint,
    sample_size: c_uint,
    channels: c_uint,
) -> AudioStream {
    return unsafe { rl::LoadAudioStream(sample_rate, sample_size, channels) };
}

/** Checks if an audio stream is ready */
pub fn is_audio_stream_ready(stream: AudioStream) -> bool {
    return unsafe { rl::IsAudioStreamReady(stream) };
}

/** Unload audio stream and free memory */
pub fn unload_audio_stream(stream: AudioStream) {
    unsafe { rl::UnloadAudioStream(stream) };
}

/** Update audio stream buffers with data */
pub fn update_audio_stream(stream: AudioStream, data: *const c_void, frame_count: c_int) {
    unsafe { rl::UpdateAudioStream(stream, data, frame_count) };
}

/** Check if any audio stream buffers requires refill */
pub fn is_audio_stream_processed(stream: AudioStream) -> bool {
    return unsafe { rl::IsAudioStreamProcessed(stream) };
}

/** Play audio stream */
pub fn play_audio_stream(stream: AudioStream) {
    unsafe { rl::PlayAudioStream(stream) };
}

/** Pause audio stream */
pub fn pause_audio_stream(stream: AudioStream) {
    unsafe { rl::PauseAudioStream(stream) };
}

/** Resume audio stream */
pub fn resume_audio_stream(stream: AudioStream) {
    unsafe { rl::ResumeAudioStream(stream) };
}

/** Check if audio stream is playing */
pub fn is_audio_stream_playing(stream: AudioStream) -> bool {
    return unsafe { rl::IsAudioStreamPlaying(stream) };
}

/** Stop audio stream */
pub fn stop_audio_stream(stream: AudioStream) {
    unsafe { rl::StopAudioStream(stream) };
}

/** Set volume for audio stream (1.0 is max level) */
pub fn set_audio_stream_volume(stream: AudioStream, volume: f32) {
    unsafe { rl::SetAudioStreamVolume(stream, volume) };
}

/** Set pitch for audio stream (1.0 is base level) */
pub fn set_audio_stream_pitch(stream: AudioStream, pitch: f32) {
    unsafe { rl::SetAudioStreamPitch(stream, pitch) };
}

/** Set pan for audio stream (0.5 is centered) */
pub fn set_audio_stream_pan(stream: AudioStream, pan: f32) {
    unsafe { rl::SetAudioStreamPan(stream, pan) };
}

/** Default size for new audio streams */
pub fn set_audio_stream_buffer_size_default(size: c_int) {
    unsafe { rl::SetAudioStreamBufferSizeDefault(size) };
}

/** Audio thread callback to request new data */
pub fn set_audio_stream_callback(stream: AudioStream, callback: AudioCallback) {
    unsafe { rl::SetAudioStreamCallback(stream, callback) };
}

/** Attach audio stream processor to stream, receives the samples as <float>s */
pub fn attach_audio_stream_processor(stream: AudioStream, processor: AudioCallback) {
    unsafe { rl::AttachAudioStreamProcessor(stream, processor) };
}

/** Detach audio stream processor from stream */
pub fn detach_audio_stream_processor(stream: AudioStream, processor: AudioCallback) {
    unsafe { rl::DetachAudioStreamProcessor(stream, processor) };
}

/** Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s */
pub fn attach_audio_mixed_processor(processor: AudioCallback) {
    unsafe { rl::AttachAudioMixedProcessor(processor) };
}

/** Detach audio stream processor from the entire audio pipeline */
pub fn detach_audio_mixed_processor(processor: AudioCallback) {
    unsafe { rl::DetachAudioMixedProcessor(processor) };
}
