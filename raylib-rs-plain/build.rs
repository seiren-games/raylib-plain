use serde::{Deserialize, Serialize};
use std::{fs, env, path::Path, time::Duration, thread};
use raylib_rs_plain_common as rl_common;
use regex::Regex;

fn main() {
	generate_define();
}

#[derive(Serialize, Deserialize)]
struct RaylibApi {
    defines: Vec<Identifier>,
}

#[derive(Serialize, Deserialize)]
struct Identifier {
    name:String,
    #[serde(rename = "type")]
    type_item:String,
    value:serde_json::Value,
}

fn generate_define() {
    let raylib_api_json_path = "../raylib-rs-plain-sys/".to_owned() + rl_common::RAYLIB_REPOSITORY_PATH + "/parser/output/raylib_api.json";

    // Sometimes raylib-rs-plain-sys build is not completed and raylib_api.json cannot be obtained.
    // - Therefore, wait until raylib_api.json can be obtained.
    let artifact_path = Path::new(&raylib_api_json_path);
    let max_attempts = 20;
    let wait_duration = Duration::from_secs(5);
    for attempt in 1..=max_attempts {
        if artifact_path.exists() {
            println!("Artifact found. Continue with build.");
            break;
        } else if attempt == max_attempts {
            panic!("Artifact not found.");
        } else {
            println!("Retry because artifact not found.({}/{})", attempt, max_attempts);
            thread::sleep(wait_duration);
        }
    }

    let content = fs::read_to_string(raylib_api_json_path).unwrap();

    let raylib_api:RaylibApi = serde_json::from_str(&content).unwrap();
    let mut raylib_define = String::new();
	let pkg_name = env::var("CARGO_PKG_NAME").unwrap();
	raylib_define.push_str(&("/* automatically generated by ".to_owned() + &pkg_name + " */\n"));
    raylib_define.push_str("use raylib_rs_plain_sys as rl;\n");
    raylib_define.push_str("pub use rl::Color;\n");
    let reg = Regex::new(r"[^0-9,]").unwrap();
    for identifier in raylib_api.defines {
        if identifier.type_item == "COLOR" {
            println!("{}", identifier.value);
            let color_value = identifier.value.to_string();
            let line = reg.replace_all(&color_value, "");
            let color_array:Vec<&str> = line.split(',').collect();
            let line = format!(
                "pub const {}:Color = Color {{r:{}, g:{}, b:{}, a:{}}};",
                identifier.name,
                color_array[0],
                color_array[1],
                color_array[2],
                color_array[3]
            );
            raylib_define.push_str(&(line + "\n"));
        }
    }

    fs::write("./src/color_define.rs", raylib_define).unwrap();
}

