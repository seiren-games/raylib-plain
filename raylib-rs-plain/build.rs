use serde::{Deserialize, Serialize};
use std::fs::ReadDir;
use std::{fs, env};
use std::io::Write;
use std::path::PathBuf;
use raylib_rs_plain_common as rl_common;

fn main() {
	generate_define();
}

#[derive(Serialize, Deserialize)]
struct RaylibApi {
    defines: Vec<Identifier>,
}

#[derive(Serialize, Deserialize)]
struct Identifier {
    name:String,
    #[serde(rename = "type")]
    type_item:String,
    value:serde_json::Value,
}

fn generate_define() {
    let content = fs::read_to_string(
        "../raylib-rs-plain-sys/".to_owned() + rl_common::RAYLIB_REPOSITORY_PATH + "/parser/output/raylib_api.json"
    ).unwrap();

    let raylib_api:RaylibApi = serde_json::from_str(&content).unwrap();
    let mut raylib_define = String::new();
	let pkg_name = env::var("CARGO_PKG_NAME").unwrap();
	raylib_define.push_str(&("/* automatically generated by ".to_owned() + &pkg_name + " */\n"));
    for identifier in raylib_api.defines {
        if identifier.type_item == "COLOR" {
            println!("{}", identifier.value);
            raylib_define.push_str(&(identifier.value.to_string() + "\n"));
        }
    }

    fs::write("./src/color_define.rs", raylib_define).unwrap();
}

